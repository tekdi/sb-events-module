import { CommonModule, DatePipe } from '@angular/common';
import { fromJS, List, Map, Set } from 'immutable';
import { Component, Input, Output, EventEmitter, ViewChild, ElementRef, ChangeDetectionStrategy, ChangeDetectorRef, Pipe, NgModule, HostListener, ComponentFactoryResolver, Directive, ViewContainerRef, Renderer2 } from '@angular/core';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule, FormsModule } from '@angular/forms';
import { Subject, from, merge } from 'rxjs';
import { tap, map, startWith, distinctUntilChanged, scan, takeUntil } from 'rxjs/operators';
import * as _ from 'lodash-es';
import { isEmpty, map as map$1, includes, find, filter, compact, cloneDeep, keys, isArray, toArray, isString, toString, split, get, forEach, flatten, groupBy, reduce } from 'lodash-es';
import { TagInputModule } from 'ngx-chips';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/common-form-elements.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CommonFormElementsComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
CommonFormElementsComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-common-form-elements',
                template: `
    <p>
      common-form-elements works!
    </p>
  `
            }] }
];
/** @nocollapse */
CommonFormElementsComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utilities/value-comparator.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValueComparator {
    /**
     * @param {?} v1
     * @param {?} v2
     * @return {?}
     */
    static valueComparator(v1, v2) {
        if (typeof v1 === 'object' && typeof v2 === 'object') {
            return ObjectUtil.equals(v1, v2);
        }
        else if (v1 === v2) {
            return true;
        }
        else if (!v1 && !v2) {
            return true;
        }
        return false;
    }
}
class ObjectUtil {
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    static equals(a, b) {
        /** @type {?} */
        const countProps = (/**
         * @param {?} obj
         * @return {?}
         */
        (obj) => {
            /** @type {?} */
            let count = 0;
            for (const k in obj) {
                if (obj.hasOwnProperty(k)) {
                    count++;
                }
            }
            return count;
        });
        /** @type {?} */
        const objectEquals = (/**
         * @param {?} v1
         * @param {?} v2
         * @return {?}
         */
        (v1, v2) => {
            if (typeof (v1) !== typeof (v2)) {
                return false;
            }
            if (typeof (v1) === 'function') {
                return v1.toString() === v2.toString();
            }
            if (v1 instanceof Object && v2 instanceof Object) {
                if (countProps(v1) !== countProps(v2)) {
                    return false;
                }
                /** @type {?} */
                let r = true;
                for (const k in v1) {
                    r = objectEquals(v1[k], v2[k]);
                    if (!r) {
                        return false;
                    }
                }
                return true;
            }
            else {
                return v1 === v2;
            }
        });
        return objectEquals(a, b);
    }
    /**
     * @param {?} newObj
     * @param {?} oldObj
     * @return {?}
     */
    static getPropDiff(newObj, oldObj) {
        return Object.keys(newObj).reduce((/**
         * @param {?} acc
         * @param {?} key
         * @return {?}
         */
        (acc, key) => {
            if (ObjectUtil.equals(newObj[key], oldObj[key])) {
                return acc;
            }
            acc.push(key);
            return acc;
        }), []);
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    static getTruthyProps(obj) {
        return Object.keys(obj).filter((/**
         * @param {?} key
         * @return {?}
         */
        (key) => !!obj[key]));
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    static toOrderedString(obj) {
        return JSON.stringify(Object.keys(obj).sort().reduce((/**
         * @param {?} acc
         * @param {?} k
         * @return {?}
         */
        (acc, k) => {
            acc[k] = obj[k];
            return acc;
        }), {}));
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/dropdown/dropdown.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DropdownComponent {
    constructor() {
        this.ValueComparator = ValueComparator;
        this.options = [];
        this.onChangeFilter = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.options) {
            this.options = [];
        }
        if (this.isOptionsClosure(this.options)) {
            this.options$ = (/** @type {?} */ (((/** @type {?} */ (this.options)))(this.formControlRef, this.context, (/**
             * @return {?}
             */
            () => this.dataLoadStatusDelegate.next('LOADING')), (/**
             * @return {?}
             */
            () => this.dataLoadStatusDelegate.next('LOADED')))));
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.context) {
            this.contextValueChangesSubscription = this.context.valueChanges.pipe(tap((/**
             * @return {?}
             */
            () => {
                this.formControlRef.patchValue(null);
            }))).subscribe();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
    }
    /**
     * @param {?} options
     * @return {?}
     */
    isOptionsArray(options) {
        return Array.isArray(options);
    }
    /**
     * @param {?} options
     * @return {?}
     */
    isOptionsClosure(options) {
        return typeof options === 'function';
    }
    /**
     * @param {?} input
     * @return {?}
     */
    isOptionsMap(input) {
        return !Array.isArray(input) && typeof input === 'object';
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onChangeFacet($event) {
        /** @type {?} */
        const selectedObject = this.options.data[$event.currentTarget.options.selectedIndex - 1];
        /** @type {?} */
        let emitPayload = JSON.parse(JSON.stringify(this.options));
        emitPayload['data'] = selectedObject;
        emitPayload['selectedLabel'] = selectedObject.label;
        emitPayload['selectedValue'] = selectedObject.value;
        this.onChangeFilter.emit(emitPayload);
    }
}
DropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-dropdown',
                template: "<div class=\"sb-dropdown\" *ngIf=\"!type\">\n  <label>{{label}}</label>\n  <ng-container *ngIf=\"options\">\n    <div class=\"dropdown-container\">\n      <sb-icon-dropdown class=\"dropdown-icon\"></sb-icon-dropdown>\n      <select [attr.disabled]=\"disabled ? true : ( context ? (context.invalid ? true : null) : null )\"\n              [formControl]=\"formControlRef\"\n              [compareWith]=\"ValueComparator.valueComparator\" class=\"sb-dropdown-select\" id=\"sb-dropdown\"\n              name=\"sb-dropdown\">\n        <option [defaultSelected]=\"!default\" [ngValue]=\"null\" disabled>{{placeHolder}}\n        </option>\n        <ng-container *ngIf=\"isOptionsArray(options)\">\n          <option *ngFor=\"let option of options\" [ngValue]=\"option.value\">{{option.label}}</option>\n        </ng-container>\n\n        <ng-container *ngIf=\"isOptionsClosure(options)\">\n          <option *ngFor=\"let option of options$ | async\" [ngValue]=\"option.value\">{{option.label}}</option>\n        </ng-container>\n\n        <ng-container *ngIf=\"isOptionsMap(options) && context && context.value\">\n          <option *ngFor=\"let option of options[context.value]\" [ngValue]=\"option.value\">{{option.label}}</option>\n        </ng-container>\n      </select>\n    </div>\n  </ng-container>\n</div>\n\n<!-- Dropdown for filters component -->\n<div class=\"sb-dropdown\" *ngIf=\"type === 'facet'\">\n  <label>{{label}}</label>\n  <ng-container *ngIf=\"options && options.data\">\n    <div class=\"dropdown-container\">\n      <sb-icon-dropdown class=\"dropdown-icon\"></sb-icon-dropdown>\n      <select [attr.disabled]=\"disabled ? true : ( context ? (context.invalid ? true : null) : null )\"\n        class=\"sb-dropdown-select\" [ngClass]=\"(styleClass ? styleClass : 'default-dropdown')\" id=\"sb-dropdown\" name=\"sb-dropdown\"\n        (change)=\"onChangeFacet($event)\" placeholder=\"placeHolder\">\n        <option *ngIf=\"!default\" [disabled]=\"true\" selected>{{placeHolder}}</option>\n        <option *ngFor=\"let option of options.data\" [ngValue]=\"option\" [selected]=\"options.default === option.value\">{{option.label}}</option>\n      </select>\n    </div>\n  </ng-container>\n</div>\n\n<!-- Dropdown for filters component -->\n",
                styles: ["label{display:block;padding:10px;font-size:1rem}.dropdown-icon{position:absolute;top:.5rem;right:18px;z-index:1}.dropdown-container{position:relative}select[disabled]{opacity:.3}select{-webkit-appearance:none;-moz-appearance:none;text-indent:1px;text-overflow:''}.sb-dropdown-select{opacity:.99;color:#333;font-family:\"Noto Sans\";font-size:12px;font-weight:700;letter-spacing:0;line-height:17px}.sb-dropdown{margin-bottom:8px}.placeholder select option:first-child{color:#999}.option-default{color:#333;font-weight:700;font-size:12px}.sb-dropdown select{background-color:#fff;padding:10px 20px;font-size:14px;width:100%;border:.5px solid #333}"]
            }] }
];
/** @nocollapse */
DropdownComponent.ctorParameters = () => [];
DropdownComponent.propDecorators = {
    disabled: [{ type: Input }],
    options: [{ type: Input }],
    label: [{ type: Input }],
    placeHolder: [{ type: Input }],
    isMultiple: [{ type: Input }],
    context: [{ type: Input }],
    formControlRef: [{ type: Input }],
    default: [{ type: Input }],
    contextData: [{ type: Input }],
    dataLoadStatusDelegate: [{ type: Input }],
    type: [{ type: Input }],
    styleClass: [{ type: Input }],
    onChangeFilter: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/textbox/textbox.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextboxComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.asyncValidation && this.asyncValidation.asyncValidatorFactory && this.formControlRef) {
            if (this.formControlRef.asyncValidator) {
                return;
            }
            this.formControlRef.setAsyncValidators(this.asyncValidation.asyncValidatorFactory(this.asyncValidation.marker, this.validationTrigger.nativeElement));
        }
    }
}
TextboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-textbox',
                template: "<div class=\"sb-input\">\n  <label *ngIf=\"label\">{{label}}</label>\n  <div *ngIf=\"labelHtml\" [innerHTML]=\"labelHtml | transposeHtml\"></div>\n\n  <div [ngClass]=\"{'async-text': (asyncValidation && asyncValidation?.trigger), '': (!asyncValidation || !asyncValidation?.trigger)}\">\n    <div class=\"prefix\" *ngIf=\"prefix\">\n      <span>{{prefix}}</span>\n    </div>\n    <input [formControl]=\"formControlRef\" class=\"sb-textbox\" placeholder={{placeholder}} type=\"text\">\n    <div class=\"async-icons\" *ngIf=\"asyncValidation && asyncValidation?.trigger\">\n      <sb-green-tick *ngIf=\"formControlRef.value && formControlRef.status === 'VALID'\"></sb-green-tick>\n      <sb-red-exclamation *ngIf=\"formControlRef.value && formControlRef.status !== 'VALID'\"></sb-red-exclamation>\n      <sb-empty-circle *ngIf=\"!formControlRef.value\"></sb-empty-circle>\n    </div>\n  </div>\n  \n  <ng-container *ngFor=\"let validation of validations\">\n    <div class=\"cf-error\"\n      *ngIf=\"(validation.type && (validation.type).toLowerCase && validation.message && formControlRef.errors && formControlRef.errors[(validation.type).toLowerCase()] && (formControlRef.dirty || formControlRef.touched))\">\n      {{ validation.message }}\n    </div>\n  </ng-container>\n  \n  <ng-container *ngIf=\"asyncValidation?.trigger\">\n    <div class=\"async-validator\"\n      [hidden]=\"formControlRef.status === 'VALID' || formControlRef.status !== 'PENDING' || !formControlRef.value\">\n      <div class=\"cf-error\" *ngIf=\"asyncValidation?.message\">\n        {{ asyncValidation.message }}\n      </div>\n      <div class=\"async-container\">\n        <button class=\"async-btn\" #validationTrigger [attr.data-marker]=\"asyncValidation.marker\">\n          {{asyncValidation.trigger}}\n        </button>\n      </div>\n    </div>\n  </ng-container>\n\n</div>\n",
                styles: ["label{display:block;font-size:1rem;margin:0}.sb-textbox{width:100%;padding:8px 16px;border:.5px solid #333;box-sizing:border-box}::-webkit-input-placeholder{padding:.25rem;opacity:.99;color:#999;font-family:\"Noto Sans\";font-size:12px;font-weight:700}::-moz-placeholder{padding:.25rem;opacity:.99;color:#999;font-family:\"Noto Sans\";font-size:12px;font-weight:700}:-ms-input-placeholder{padding:.25rem;opacity:.99;color:#999;font-family:\"Noto Sans\";font-size:12px;font-weight:700}::-ms-input-placeholder{padding:.25rem;opacity:.99;color:#999;font-family:\"Noto Sans\";font-size:12px;font-weight:700}::placeholder{padding:.25rem;opacity:.99;color:#999;font-family:\"Noto Sans\";font-size:12px;font-weight:700}.sb-input{margin:1rem 0}.cf-error{color:red;font-family:\"Noto Sans\";font-size:12px}.async-container{text-align:center}.async-btn{padding:12px 16px;background-color:#008840;color:#fff;border-radius:20px!important}.async-text{display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;border:.5px solid #333}.async-text>input{border:none}.normal-text>.async-icons>sb-empty-circle,.normal-text>.async-icons>sb-green-tick,.normal-text>.async-icons>sb-red-exclamation{display:none}.prefix{white-space:nowrap;padding:0 4px}.async-icons{margin:auto;padding:0 4px}"]
            }] }
];
/** @nocollapse */
TextboxComponent.ctorParameters = () => [];
TextboxComponent.propDecorators = {
    asyncValidation: [{ type: Input }],
    label: [{ type: Input }],
    labelHtml: [{ type: Input }],
    placeholder: [{ type: Input }],
    validations: [{ type: Input }],
    formControlRef: [{ type: Input }],
    prefix: [{ type: Input }],
    validationTrigger: [{ type: ViewChild, args: ['validationTrigger', { static: false },] }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/common-form-config.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const FieldConfigInputType = {
    INPUT: "input",
    CHECKBOX: "checkbox",
    SELECT: "select",
    LABEL: "label",
    TEXTAREA: "textarea",
    NESTED_SELECT: "nested_select",
    NESTED_GROUP: "nested_group",
    MULTIPLE_SELECT: "multiple_select",
};
/** @enum {string} */
const FieldConfigValidationType = {
    REQUIRED: "required",
    MAXLENGTH: "maxLength",
    REQUIRED_TRUE: "required_true",
    MINLENGTH: "minLength",
    PATTERN: "pattern",
};
/** @enum {string} */
const FilterType = {
    FACET: "facet",
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/textarea/textarea.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextareaComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const maxLengthValidation = this.config.validations && this.config.validations.find((/**
         * @param {?} validation
         * @return {?}
         */
        (validation) => validation.type === FieldConfigValidationType.MAXLENGTH));
        if (maxLengthValidation) {
            this.remainderValidLength$ = this.formControlRef.valueChanges.pipe(startWith(''), map((/**
             * @param {?} v
             * @return {?}
             */
            (v) => ((typeof maxLengthValidation.value === 'number') ? maxLengthValidation.value : 0) - (v || '').length)));
        }
    }
}
TextareaComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-textarea',
                template: "<div class=\"sb-textarea-container\">\n  <label>{{label}}</label>\n  <textarea class=\"sb-textarea\" [formControl]=\"formControlRef\" rows=\"5\" name=\"sb-textarea\" placeholder={{placeholder}}>\n  </textarea>\n  <div class=\"remaining-length\" *ngIf=\"remainderValidLength$\">\n     {{remainderValidLength$ | async}} Characters left\n  </div>\n</div>\n",
                styles: ["label{display:block;padding:8px 0 0;font-size:14px}.sb-textarea{width:100%;padding:8px;box-sizing:border-box;border:1px solid #ccc;border-radius:.25rem;resize:vertical}.sb-textarea-container{margin-bottom:10px;position:relative}.remaining-length{position:absolute;bottom:.5rem;right:1rem;font-size:10px;color:#999}::-webkit-input-placeholder{padding:.25rem;color:#999;font-family:\"Noto Sans\";font-size:14px;letter-spacing:0;line-height:20px}::-moz-placeholder{padding:.25rem;color:#999;font-family:\"Noto Sans\";font-size:14px;letter-spacing:0;line-height:20px}:-ms-input-placeholder{padding:.25rem;color:#999;font-family:\"Noto Sans\";font-size:14px;letter-spacing:0;line-height:20px}::-ms-input-placeholder{padding:.25rem;color:#999;font-family:\"Noto Sans\";font-size:14px;letter-spacing:0;line-height:20px}::placeholder{padding:.25rem;color:#999;font-family:\"Noto Sans\";font-size:14px;letter-spacing:0;line-height:20px}"]
            }] }
];
/** @nocollapse */
TextareaComponent.ctorParameters = () => [];
TextareaComponent.propDecorators = {
    label: [{ type: Input }],
    placeholder: [{ type: Input }],
    formControlRef: [{ type: Input }],
    config: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/checkbox/checkbox.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckboxComponent {
    constructor() {
        this.clickedLink = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        console.log('label', this.label);
        console.log('labelHtml', this.labelHtml);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleLinkClick(event) {
        if (event.target && event.target['hasAttribute'] && ((/** @type {?} */ (event.target))).hasAttribute('href')) {
            this.clickedLink.emit(((/** @type {?} */ (event.target))).getAttribute('href'));
        }
    }
}
CheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-checkbox',
                template: "<div class=\"sb-checkbox\">\n    <div class=\"checkbox-row\">\n        <label class=\"container\">\n            <input type=\"checkbox\" [formControl]=\"formControlRef\" name=\"checkbox\" value=\"value\">\n            <span class=\"checkmark\"></span>\n        </label>\n        <label *ngIf=\"label\" class=\"checkbox-label\">{{label}}</label>\n        <label class=\"label-html\" *ngIf=\"labelHtml\">\n            <div [innerHTML]=\"labelHtml | transposeHtml\" (click)=\"handleLinkClick($event)\"></div>\n        </label>\n    </div>\n</div>",
                styles: ["label{font-size:16px}.sb-checkbox{padding:0 0 0 8px}.container{position:relative;cursor:pointer;font-size:22px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.container input{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.container .checkmark{position:absolute;top:0;left:0;height:22px;width:22px;border:2px solid #000;border-radius:4px}.container input:checked~.checkmark{background-color:#2196f3}.checkmark:after{content:\"\";position:absolute;display:none}.container input:checked~.checkmark:after{display:block}.container .checkmark:after{left:7px;top:4px;width:5px;height:9px;border:solid #fff;border-width:0 3px 3px 0;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.checkbox-label{padding:2px 0 0 32px}.checkbox-row{display:-ms-grid;display:grid;-ms-grid-columns:10% 90%;grid-template-columns:10% 90%;grid-gap:0}.label-html{font-size:14px}"]
            }] }
];
/** @nocollapse */
CheckboxComponent.ctorParameters = () => [];
CheckboxComponent.propDecorators = {
    label: [{ type: Input }],
    code: [{ type: Input }],
    value: [{ type: Input }],
    formControlRef: [{ type: Input }],
    labelHtml: [{ type: Input }],
    clickedLink: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form/form.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormComponent {
    /**
     * @param {?} formBuilder
     */
    constructor(formBuilder) {
        this.formBuilder = formBuilder;
        this.initialize = new EventEmitter();
        this.finalize = new EventEmitter();
        this.linkClicked = new EventEmitter();
        this.valueChanges = new EventEmitter();
        this.statusChanges = new EventEmitter();
        this.platform = 'web';
        this.dataLoadStatus = new EventEmitter();
        this.dataLoadStatusDelegate = new Subject();
        this.FieldConfigInputType = FieldConfigInputType;
        if (!window['forms']) {
            window['forms'] = [];
        }
        window['forms'].push(this);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.finalize.emit();
        if (this.statusChangesSubscription) {
            this.statusChangesSubscription.unsubscribe();
        }
        if (this.valueChangesSubscription) {
            this.valueChangesSubscription.unsubscribe();
        }
        if (this.dataLoadStatusSinkSubscription) {
            this.dataLoadStatusSinkSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['config']) {
            if ((changes['config'].currentValue && changes['config'].firstChange) || changes['config'].previousValue !== changes['config'].currentValue) {
                this.initializeForm();
            }
        }
        if (this.dataLoadStatusSinkSubscription) {
            this.dataLoadStatusSinkSubscription.unsubscribe();
        }
        if (this.statusChangesSubscription) {
            this.statusChangesSubscription.unsubscribe();
        }
        if (this.valueChangesSubscription) {
            this.valueChangesSubscription.unsubscribe();
        }
        this.dataLoadStatusSinkSubscription = this.dataLoadStatusDelegate.pipe(scan((/**
         * @param {?} acc
         * @param {?} event
         * @return {?}
         */
        (acc, event) => {
            if (event === 'LOADED') {
                acc.loadedCount++;
                return acc;
            }
            acc.loadingCount++;
            return acc;
        }), { loadingCount: 0, loadedCount: 0 }), map((/**
         * @param {?} aggregates
         * @return {?}
         */
        (aggregates) => {
            if (aggregates.loadingCount !== aggregates.loadedCount) {
                return 'LOADING';
            }
            return 'LOADED';
        })), distinctUntilChanged(), tap((/**
         * @param {?} result
         * @return {?}
         */
        (result) => {
            if (result === 'LOADING') {
                this.dataLoadStatus.emit('LOADING');
            }
            else {
                this.dataLoadStatus.emit('LOADED');
            }
        }))).subscribe();
        this.statusChangesSubscription = this.formGroup.statusChanges.pipe(tap((/**
         * @param {?} v
         * @return {?}
         */
        (v) => {
            this.statusChanges.emit({
                isPristine: this.formGroup.pristine,
                isDirty: this.formGroup.dirty,
                isInvalid: this.formGroup.invalid,
                isValid: this.formGroup.valid
            });
        }))).subscribe();
        this.valueChangesSubscription = this.formGroup.valueChanges.pipe(tap((/**
         * @param {?} v
         * @return {?}
         */
        (v) => {
            this.valueChanges.emit(v);
        }))).subscribe();
    }
    /**
     * @param {?} nestedFormGroup
     * @param {?} fieldConfig
     * @return {?}
     */
    onNestedFormFinalize(nestedFormGroup, fieldConfig) {
        if (!this.formGroup.get('children') || !this.formGroup.get(`children.${fieldConfig.code}`)) {
            return;
        }
        ((/** @type {?} */ (this.formGroup.get('children')))).removeControl(fieldConfig.code);
        if (!Object.keys(((/** @type {?} */ (this.formGroup.get('children')))).controls).length) {
            this.formGroup.removeControl('children');
        }
    }
    /**
     * @param {?} nestedFormGroup
     * @param {?} fieldConfig
     * @return {?}
     */
    onNestedFormInitialize(nestedFormGroup, fieldConfig) {
        if (!this.formGroup.get('children')) {
            this.formGroup.addControl('children', new FormGroup({}));
        }
        ((/** @type {?} */ (this.formGroup.get('children')))).removeControl(fieldConfig.code);
        ((/** @type {?} */ (this.formGroup.get('children')))).addControl(fieldConfig.code, nestedFormGroup);
    }
    /**
     * @private
     * @return {?}
     */
    initializeForm() {
        if (!this.config.length) {
            console.error('FORM LIST IS EMPTY');
            return;
        }
        /** @type {?} */
        const formGroupData = {};
        this.config.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (element.type !== FieldConfigInputType.LABEL) {
                /** @type {?} */
                const formValueList = this.prepareFormValidationData(element, index);
                formGroupData[element.code] = formValueList;
            }
        }));
        this.formGroup = this.formBuilder.group(formGroupData);
        this.initialize.emit(this.formGroup);
    }
    /**
     * @private
     * @param {?} element
     * @param {?} index
     * @return {?}
     */
    prepareFormValidationData(element, index) {
        /** @type {?} */
        const formValueList = [];
        /** @type {?} */
        const validationList = [];
        /** @type {?} */
        let defaultVal = '';
        switch (element.type) {
            case FieldConfigInputType.INPUT:
                defaultVal = element.templateOptions.type === 'number' ?
                    (element.default && Number.isInteger(element.default) ? element.default : 0) :
                    (element.default && (typeof element.default) === 'string' ? element.default : '');
                break;
            case FieldConfigInputType.SELECT:
            case FieldConfigInputType.NESTED_SELECT:
                defaultVal = element.templateOptions.multiple ?
                    (element.default && Array.isArray(element.default) ? element.default : []) : (element.default || null);
                break;
            case FieldConfigInputType.CHECKBOX:
                defaultVal = !!element.default;
                break;
        }
        formValueList.push(defaultVal);
        if (element.validations && element.validations.length) {
            element.validations.forEach((/**
             * @param {?} data
             * @param {?} i
             * @return {?}
             */
            (data, i) => {
                switch (data.type) {
                    case FieldConfigValidationType.REQUIRED:
                        if (element.type === FieldConfigInputType.CHECKBOX) {
                            validationList.push(Validators.requiredTrue);
                        }
                        else if (element.type === FieldConfigInputType.SELECT || element.type === FieldConfigInputType.NESTED_SELECT) {
                            validationList.push((/**
                             * @param {?} c
                             * @return {?}
                             */
                            (c) => {
                                if (element.templateOptions.multiple) {
                                    return c.value && c.value.length ? null : 'error';
                                }
                                return !!c.value ? null : 'error';
                            }));
                        }
                        else {
                            validationList.push(Validators.required);
                        }
                        break;
                    case FieldConfigValidationType.PATTERN:
                        validationList.push(Validators.pattern((/** @type {?} */ (element.validations[i].value))));
                        break;
                    case FieldConfigValidationType.MINLENGTH:
                        validationList.push(Validators.minLength((/** @type {?} */ (element.validations[i].value))));
                        break;
                    case FieldConfigValidationType.MAXLENGTH:
                        validationList.push(Validators.maxLength((/** @type {?} */ (element.validations[i].value))));
                        break;
                }
            }));
        }
        formValueList.push(Validators.compose(validationList));
        return formValueList;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    clickedLink(event) {
        this.linkClicked.emit(event);
    }
}
FormComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-form',
                template: "<div [formGroup]=\"formGroup\">\n  <ng-container *ngFor=\"let field of config; let index = i\">\n      <!-- <div *ngIf=\"field.type === FieldConfigInputType.SELECT && !field.templateOptions.multiple\" [hidden]=\"field.templateOptions?.hidden || null\">\n        <sb-dropdown [context]=\"field.context ? formGroup.get(field.context) : null \" [default]=\"field.default\"\n          [formControlRef]=\"formGroup.get(field.code)\" [label]=\"field.templateOptions.label\"\n          [dataLoadStatusDelegate]=\"dataLoadStatusDelegate\" [options]=\"field.templateOptions?.options\"\n          [disabled]=\"field.templateOptions?.disabled\" [placeHolder]=\"field?.templateOptions?.placeHolder\">\n        </sb-dropdown>\n      </div>\n    <div *ngIf=\"field.type === FieldConfigInputType.NESTED_SELECT\" [hidden]=\"field.templateOptions?.hidden || null\">\n      <sb-dropdown [context]=\"field.context ? formGroup.get(field.context) : null \" [default]=\"field.default\"\n        [formControlRef]=\"formGroup.get(field.code)\" [label]=\"field.templateOptions.label\"\n        [dataLoadStatusDelegate]=\"dataLoadStatusDelegate\" [options]=\"field.templateOptions?.options\"\n        [disabled]=\"field.templateOptions?.disabled\" [placeHolder]=\"field?.templateOptions?.placeHolder\">\n      </sb-dropdown>\n    </div> -->\n    <div *ngIf=\"field.type === FieldConfigInputType.SELECT || field.type === FieldConfigInputType.NESTED_SELECT\" [hidden]=\"field.templateOptions?.hidden || null\">\n      <sb-multiple-dropdown [context]=\"field.context ? formGroup.get(field.context) : null \" [default]=\"field.default\"\n        [formControlRef]=\"formGroup.get(field.code)\" [options]=\"field.templateOptions?.options\"\n        [label]=\"field.templateOptions.label\" [dataLoadStatusDelegate]=\"dataLoadStatusDelegate\"\n        [disabled]=\"field.templateOptions?.disabled\" [placeHolder]=\"field?.templateOptions?.placeHolder\" \n        [isMultiple]=\"field.templateOptions.multiple\" [labelHtml]=\"field.templateOptions.labelHtml\">\n      </sb-multiple-dropdown>\n    </div>\n    <div *ngIf=\"field.type === FieldConfigInputType.INPUT\" [hidden]=\"field.templateOptions?.hidden || null\">\n      <sb-textbox [formControlRef]=\"formGroup.get(field.code)\" [asyncValidation]=\"field.asyncValidation\" [label]=\"field.templateOptions.label\"\n        [placeholder]=\"field.templateOptions.placeHolder\" [validations]=\"field.validations\" [prefix]=\"field.templateOptions.prefix\"\n        [labelHtml]=\"field.templateOptions.labelHtml\">\n      </sb-textbox>\n    </div>\n    <div *ngIf=\"field.type === FieldConfigInputType.TEXTAREA\" [hidden]=\"field.templateOptions?.hidden || null\">\n      <sb-textarea [config]=\"field\" [formControlRef]=\"formGroup.get(field.code)\" [label]=\"field.templateOptions.label\"\n        [placeholder]=\"field.templateOptions.placeHolder\">\n      </sb-textarea>\n    </div>\n    <div *ngIf=\"field.type === FieldConfigInputType.CHECKBOX\" [hidden]=\"field.templateOptions?.hidden || null\">\n      <sb-checkbox [code]=\"field.code\" [formControlRef]=\"formGroup.get(field.code)\"\n        [label]=\"field.templateOptions.label\" [labelHtml]=\"field.templateOptions.labelHtml\" [value]=\"field.default\"\n        (clickedLink)=\"clickedLink($event)\"></sb-checkbox>\n    </div>\n    <div *ngIf=\"asyncValidatorFactory && field.asyncValidation?.trigger\">\n      <button #validationTrigger [attr.data-marker]=\"field.asyncValidation.marker\">\n        {{field.asyncValidation.trigger}}\n      </button>\n    </div>\n    <ng-container *ngIf=\"formGroup.get(field.code) as ref\">\n      <div *ngIf=\"field.type === FieldConfigInputType.NESTED_SELECT && ref && ref.value && field.children && field.children[ref.value]\">\n        <sb-form (initialize)=\"onNestedFormInitialize($event, field)\" (finalize)=\"onNestedFormFinalize($event, field)\"\n          [dataLoadStatusDelegate]=\"dataLoadStatusDelegate\" [config]=\"field.children[ref.value]\"></sb-form>\n      </div>\n\n      <div *ngIf=\"field.type === FieldConfigInputType.NESTED_GROUP && field.children\">\n        <sb-form (initialize)=\"onNestedFormInitialize($event, field)\" (finalize)=\"onNestedFormFinalize($event, field)\"\n          [dataLoadStatusDelegate]=\"dataLoadStatusDelegate\" [config]=\"field.children\"></sb-form>\n      </div>\n    </ng-container>\n\n    <ng-container *ngIf=\"field.type === FieldConfigInputType.LABEL\">\n      <label *ngIf=\"field.templateOptions?.label\">{{field.templateOptions?.label}}</label>\n      <div *ngIf=\"field.templateOptions?.labelHtml\" [innerHTML]=\"field.templateOptions?.labelHtml | transposeHtml\"></div>\n    </ng-container>\n    \n  </ng-container>\n</div>",
                styles: [""]
            }] }
];
/** @nocollapse */
FormComponent.ctorParameters = () => [
    { type: FormBuilder }
];
FormComponent.propDecorators = {
    initialize: [{ type: Output }],
    finalize: [{ type: Output }],
    linkClicked: [{ type: Output }],
    valueChanges: [{ type: Output }],
    statusChanges: [{ type: Output }],
    platform: [{ type: Input }],
    dataLoadStatus: [{ type: Output }],
    config: [{ type: Input }],
    dataLoadStatusDelegate: [{ type: Input }],
    asyncValidatorFactory: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/option-group/option-group.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OptionGroupComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
OptionGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-option-group',
                template: "<p>\n  option-group works!\n</p>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            }] }
];
/** @nocollapse */
OptionGroupComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/icon/dropdown/dropdownIcon.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DropdownIconComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
DropdownIconComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-icon-dropdown',
                template: "<svg width=\"14px\" height=\"8px\" viewBox=\"0 0 14 8\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <!-- Generator: sketchtool 63.1 (101010) - https://sketch.com -->\n    <title>BE94B3C8-E695-41FA-A0FC-2CE95714B444@1.5x</title>\n    <desc>Created with sketchtool.</desc>\n    <g id=\"Schooling-@-home\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n        <g id=\"My-classes-Copy\" transform=\"translate(-316.000000, -248.000000)\" fill=\"#333333\">\n            <g id=\"Group\" transform=\"translate(16.000000, 205.000000)\">\n                <polygon id=\"Path\" transform=\"translate(306.894756, 47.000000) rotate(-270.000000) translate(-306.894756, -47.000000) \" points=\"304.599756 40.7073171 303.189756 42.1860976 307.769756 47 303.189756 51.8139024 304.599756 53.2926829 310.599756 47\"></polygon>\n            </g>\n        </g>\n    </g>\n</svg>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
DropdownIconComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/multiple-dropdown/multiple-dropdown.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MultipleDropdownComponent {
    /**
     * @param {?} changeDetectionRef
     */
    constructor(changeDetectionRef) {
        this.changeDetectionRef = changeDetectionRef;
        this.showModal = false;
        this.tempValue = Set();
        this.resolvedOptions = List();
        this.optionValueToOptionLabelMap = Map();
        this.fromJS = fromJS;
        this.dispose$ = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.context) {
            this.context.valueChanges.pipe(tap((/**
             * @return {?}
             */
            () => {
                this.formControlRef.patchValue(null);
                this.tempValue = this.tempValue.clear();
                this.setupOptions();
            })), takeUntil(this.dispose$)).subscribe();
        }
        this.formControlRef.valueChanges.pipe(tap((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this.setTempValue(value);
            this.changeDetectionRef.detectChanges();
        })), takeUntil(this.dispose$)).subscribe();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!changes['options'] || !changes['options'].currentValue) {
            return;
        }
        this.setupOptions();
    }
    /**
     * @return {?}
     */
    onSubmit() {
        /** @type {?} */
        const finalValue = this.tempValue.toList().toJS();
        this.formControlRef.patchValue(this.isMultiple ? finalValue : finalValue[0]);
        this.formControlRef.markAsDirty();
        this.showModal = false;
    }
    /**
     * @return {?}
     */
    openModal() {
        if (this.context && this.context.invalid) {
            return;
        }
        this.setTempValue(this.formControlRef.value);
        this.showModal = true;
    }
    /**
     * @param {?} option
     * @return {?}
     */
    addSelected(option) {
        if (this.isMultiple) {
            if (this.tempValue.includes(option.get('value'))) {
                this.tempValue = this.tempValue.remove(option.get('value'));
            }
            else {
                this.tempValue = this.tempValue.add(option.get('value'));
            }
        }
        else {
            this.tempValue = this.tempValue.clear();
            this.tempValue = this.tempValue.add(option.get('value'));
        }
    }
    /**
     * @return {?}
     */
    onCancel() {
        this.formControlRef.markAsDirty();
        this.showModal = false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.dispose$.next(null);
        this.dispose$.complete();
    }
    /**
     * @private
     * @return {?}
     */
    isOptionsArray() {
        return Array.isArray(this.options);
    }
    /**
     * @private
     * @return {?}
     */
    isOptionsClosure() {
        return typeof this.options === 'function';
    }
    /**
     * @private
     * @return {?}
     */
    isOptionsMap() {
        return !Array.isArray(this.options) && typeof this.options === 'object';
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    setTempValue(value) {
        if (value) {
            if (Array.isArray(value)) {
                this.tempValue = Set(fromJS(value));
            }
            else {
                this.tempValue = Set(fromJS([value]));
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    setupOptions() {
        if (!this.options) {
            this.options = [];
            this.resolvedOptions = this.resolvedOptions.clear();
        }
        if (this.isOptionsArray()) {
            this.resolvedOptions = fromJS(this.options);
        }
        else if (this.isOptionsMap()) {
            this.resolvedOptions = (this.context && this.context.value) ?
                fromJS(this.options[this.context.value]) :
                this.resolvedOptions;
        }
        else if (this.isOptionsClosure()) {
            from(((/** @type {?} */ (this.options)))(this.formControlRef, this.context, (/**
             * @return {?}
             */
            () => this.dataLoadStatusDelegate.next('LOADING')), (/**
             * @return {?}
             */
            () => this.dataLoadStatusDelegate.next('LOADED')))).pipe(tap((/**
             * @param {?=} options
             * @return {?}
             */
            (options = []) => {
                this.resolvedOptions = fromJS(options);
                this.resolvedOptions.forEach((/**
                 * @param {?} option
                 * @return {?}
                 */
                (option) => {
                    this.optionValueToOptionLabelMap = this.optionValueToOptionLabelMap.set(option.get('value'), option.get('label'));
                }));
                this.setTempValue(this.default);
                this.changeDetectionRef.detectChanges();
            })), takeUntil(this.dispose$)).subscribe();
        }
        this.resolvedOptions.forEach((/**
         * @param {?} option
         * @return {?}
         */
        (option) => {
            this.optionValueToOptionLabelMap = this.optionValueToOptionLabelMap.set(option.get('value'), option.get('label'));
        }));
        this.setTempValue(this.default);
    }
}
MultipleDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-multiple-dropdown',
                template: "<div class=\"multi-select-section\">\n  <label class=\"input-label\" *ngIf=\"label\">{{label}}</label>\n  <div *ngIf=\"labelHtml\" [innerHTML]=\"labelHtml | transposeHtml\"></div>\n  <div class=\"multi-select-container\">\n    <sb-caret-down class=\"caret-down\"\n      [attr.disabled]=\"disabled ? true : ( context ? (context.invalid ? true : null) : null )\" (click)=\"openModal()\">\n    </sb-caret-down>\n    <div class=\"list-border\" (click)=\"openModal()\">\n      <ul [attr.disabled]=\"disabled ? true : ( context ? (context.invalid ? true : null) : null )\">\n        <ng-container *ngIf=\"isMultiple\">\n          <li *ngIf=\"!formControlRef.value || !formControlRef.value.length\" class=\"placeholder\">{{placeHolder}}</li>\n\n          <ng-container *ngIf=\"formControlRef.value?.length\">\n            <span *ngFor=\"let value of formControlRef.value; let index=index\">\n              {{optionValueToOptionLabelMap.get(fromJS(value))}}<span\n            *ngIf=\"index < formControlRef.value.length - 1\">, </span>\n            </span>\n          </ng-container>\n        </ng-container>\n\n        <ng-container *ngIf=\"!isMultiple\">\n          <li *ngIf=\"!formControlRef.value\" class=\"placeholder\">{{placeHolder}}</li>\n\n          <span *ngIf=\"formControlRef.value\">{{optionValueToOptionLabelMap.get(fromJS(formControlRef.value))}}</span>\n        </ng-container>\n      </ul>\n    </div>\n    <div class=\"sb-modal-container\" [hidden]=\"!showModal\" (click)=\"showModal=false;\">\n      <div class=\"sb-modal-overlay\">\n        <div class=\"sb-modal\" (click)=\"$event.stopPropagation()\">\n          <div class=\"header\">\n            {{placeHolder}}\n          </div>\n          <div class=\"body\">\n            <ul>\n              <li *ngFor=\"let option of resolvedOptions; let i=index\">\n                <div (click)=\"addSelected(option)\" class=\"row\">\n                  <label class=\"container\" style=\"pointer-events: none\">\n                    <input [checked]=\"tempValue.includes(option.get('value'))\" class=\"sb-checkbox\" type=\"checkbox\">\n                    <span class=\"checkmark\"></span>\n                  </label>\n                  <span>{{option.get('label')}}</span>\n                </div>\n              </li>\n            </ul>\n          </div>\n          <div class=\"footer\">\n            <div class=\"sb-form-button\">\n              <button class=\"sb-btn-primary-outline\" (click)=\"onCancel()\">cancel</button>\n            </div>\n            <div class=\"sb-form-button\">\n              <button class=\"sb-btn-primary\" (click)=\"onSubmit()\">submit</button>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".multi-select-section{margin:1rem 0}label{font-size:1rem;margin:0}.multi-select-container{position:relative;margin-bottom:8px}.multi-select-container .caret-down{position:absolute;top:11px;right:19px;z-index:0}.multi-select-container .list-border .placeholder{font-size:12px;font-weight:700;margin-left:12px;color:var(--gray-100)}.multi-select-container .list-border ul[disabled]{opacity:.3;pointer-events:none}.multi-select-container .list-border ul{list-style-type:none;margin-top:3px;margin-left:8px;position:absolute;top:0;left:0}.multi-select-container .list-border{border:.5px solid var(--gray-400);padding:1.3rem;cursor:pointer}.multi-select-container .list-border li{float:left;font-size:12px;font-weight:700;margin-left:4px}.multi-select-container .dropdown li{cursor:pointer;padding:8px;border:1px solid var(--white)}.multi-select-container .dropdown ul{list-style-type:none;margin:0;padding:0}.multi-select-container .row{display:-ms-grid;display:grid;-ms-grid-columns:1fr 10fr;grid-template-columns:1fr 10fr;grid-gap:0}.multi-select-container .footer{display:-ms-grid;display:grid;-ms-grid-columns:1fr 1fr;grid-template-columns:1fr 1fr;grid-gap:0;padding-left:8px;padding-bottom:8px;padding-top:8px}.multi-select-container .sb-modal-container{position:fixed;height:100vh;overflow:hidden;width:100%;left:0;top:0;right:0;z-index:10}.multi-select-container .sb-modal-overlay{position:absolute;width:100%;height:100%;top:0;background:rgba(0,0,0,.6);left:0;z-index:10}.multi-select-container .fa .fa-close{float:right}.multi-select-container .sb-modal{display:block;position:absolute;bottom:0;width:100%;--border-top:0.5px solid var(--white);z-index:11;background:var(--white)}.multi-select-container .sb-modal ul{list-style-type:none}.multi-select-container .sb-modal li{cursor:pointer;padding-bottom:8px;padding-top:8px;padding-left:16px}.value-label{width:270px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.multi-select-container .sb-forms-radio{margin-top:6px}.multi-select-container .sb-form-button{display:inline;padding:10px}.multi-select-container .sb-btn-primary-outline{color:var(--primary-color);background-color:transparent;border:.5px solid var(--primary-color);border-radius:4px;padding:10px 40px;font-size:16px;text-transform:uppercase;width:100%}.multi-select-container .sb-btn-primary{color:var(--white);background-color:var(--primary-color);border:.5px solid var(--primary-color);border-radius:4px;padding:10px 40px;font-size:16px;text-transform:uppercase;width:100%}.multi-select-container .header{padding:16px;margin-left:8px;font-weight:700}.multi-select-container .body{padding-top:8px;border-bottom:.5px solid var(--gray-100);border-top:.5px solid var(--gray-100);max-height:300px;overflow:scroll}.list-with-ellipsis:nth-child(3){float:left;font-size:12px;font-weight:700;margin-left:4px;width:50px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.list-with-ellipsis:nth-child(n+4){visibility:hidden}.multi-select-container .container{display:block;position:relative;padding-left:35px;margin-bottom:12px;cursor:pointer;font-size:22px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.container input{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.checkmark{position:absolute;top:3px;left:0;height:15px;width:15px;border:.4px solid var(--black)}.container:hover input~.checkmark{background-color:var(--white)}.container input:checked~.checkmark{background-color:var(--primary-600)}.checkmark:after{content:\"\";position:absolute;display:none}.container input:checked~.checkmark:after{display:block}.container .checkmark:after{left:5px;top:0;width:5px;height:10px;border:solid var(--white);border-width:0 2px 2px 0;-webkit-transform:rotate(45deg);transform:rotate(45deg)}"]
            }] }
];
/** @nocollapse */
MultipleDropdownComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
MultipleDropdownComponent.propDecorators = {
    disabled: [{ type: Input }],
    options: [{ type: Input }],
    label: [{ type: Input }],
    labelHtml: [{ type: Input }],
    placeHolder: [{ type: Input }],
    isMultiple: [{ type: Input }],
    context: [{ type: Input }],
    formControlRef: [{ type: Input }],
    default: [{ type: Input }],
    contextData: [{ type: Input }],
    dataLoadStatusDelegate: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/icon/caret-down/caret-down.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CaretDownComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
CaretDownComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-caret-down',
                template: "<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\"\n\t width=\"12px\" height=\"12px\" viewBox=\"0 0 451.847 451.847\" style=\"enable-background:new 0 0 451.847 451.847;\"\n\t xml:space=\"preserve\">\n<g>\n\t<path d=\"M225.923,354.706c-8.098,0-16.195-3.092-22.369-9.263L9.27,151.157c-12.359-12.359-12.359-32.397,0-44.751\n\t\tc12.354-12.354,32.388-12.354,44.748,0l171.905,171.915l171.906-171.909c12.359-12.354,32.391-12.354,44.744,0\n\t\tc12.365,12.354,12.365,32.392,0,44.751L248.292,345.449C242.115,351.621,234.018,354.706,225.923,354.706z\"/>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n</svg>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
CaretDownComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/transpose-html/transpose-html.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TransposeHtmlPipe {
    constructor() { }
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        return Object.keys(value.values).reduce((/**
         * @param {?} acc
         * @param {?} val
         * @return {?}
         */
        (acc, val) => {
            return acc.replace(val, value.values[val] ? value.values[val] : '');
        }), value.contents);
    }
}
TransposeHtmlPipe.decorators = [
    { type: Pipe, args: [{ name: 'transposeHtml' },] }
];
/** @nocollapse */
TransposeHtmlPipe.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/pipes.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PipesModule {
}
PipesModule.decorators = [
    { type: NgModule, args: [{
                declarations: [TransposeHtmlPipe],
                imports: [CommonModule],
                exports: [TransposeHtmlPipe],
                providers: [DatePipe]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/icon/red-exclamation/red-exclamation.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RedExclamationComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
RedExclamationComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-red-exclamation',
                template: "<svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" style=\"padding-top:4px\">\n    <title>F7461929-9D59-4C06-97CD-845F9C506BE5</title>\n    <g id=\"Profile-Page\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n        <g id=\"Self-Declaration-Teacher-04-.1\" transform=\"translate(-304.000000, -325.000000)\" fill-rule=\"nonzero\">\n            <g id=\"Group-3-Copy-6\" transform=\"translate(16.000000, 290.000000)\">\n                <g id=\"Red\" transform=\"translate(288.000000, 35.000000)\">\n                    <path d=\"M12,0 C18.627417,0 24,5.372583 24,12 C24,18.627417 18.627417,24 12,24 C5.372583,24 0,18.627417 0,12 C0,5.372583 5.372583,0 12,0 Z\" id=\"Oval\" fill=\"#E55A28\"></path>\n                    <path d=\"M13,8.66891892 L13,7 L11,7 L11,8.66891892 L13,8.66891892 Z M13,17.3378378 L13,9.91891892 L11,9.91891892 L11,17.3378378 L13,17.3378378 Z\" id=\"i\" fill=\"#FFFFFF\" transform=\"translate(12.000000, 12.168919) rotate(-180.000000) translate(-12.000000, -12.168919) \"></path>\n                </g>\n            </g>\n        </g>\n    </g>\n</svg>",
                styles: [""]
            }] }
];
/** @nocollapse */
RedExclamationComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/icon/green-tick/green-tick.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GreenTickComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
GreenTickComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-green-tick',
                template: "<svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" style=\"padding-top:4px\">\n    <title>8B4CB432-FD76-4469-94B8-BCC3D605009F</title>\n    <g id=\"Profile-Page\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n        <g id=\"Self-Declaration-Teacher-04.4\" transform=\"translate(-304.000000, -325.000000)\" fill-rule=\"nonzero\">\n            <g id=\"Group-3-Copy-6\" transform=\"translate(16.000000, 290.000000)\">\n                <g id=\"Green\" transform=\"translate(288.000000, 35.000000)\">\n                    <path d=\"M12,0 C18.627417,0 24,5.372583 24,12 C24,18.627417 18.627417,24 12,24 C5.372583,24 0,18.627417 0,12 C0,5.372583 5.372583,0 12,0 Z\" id=\"Oval\" fill=\"#008840\"></path>\n                    <path d=\"M12,2 C6.4771525,2 2,6.4771525 2,12 C2,17.5228475 6.4771525,22 12,22 C17.5228475,22 22,17.5228475 22,12 C22,6.4771525 17.5228475,2 12,2 Z\" id=\"Path\" fill=\"#008840\"></path>\n                    <polygon id=\"Path\" fill=\"#FFFFFF\" points=\"16.59 7 10 13.9957537 7.41 11.2569002 6 12.7537155 10 17 18 8.507431\"></polygon>\n                </g>\n            </g>\n        </g>\n    </g>\n</svg>",
                styles: [""]
            }] }
];
/** @nocollapse */
GreenTickComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/icon/empty-circle/empty-circle.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EmptyCircleComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
EmptyCircleComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-empty-circle',
                template: "<svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" style=\"padding-top:4px\">\n    <title>0A5AE039-B21E-4EB7-98C2-533D33CCFEB7</title>\n    <g id=\"Profile-Page\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n        <g id=\"Self-Declaration-Teacher-04\" transform=\"translate(-304.000000, -325.000000)\" stroke=\"#CCCCCC\" stroke-width=\"2\">\n            <g id=\"Group-3-Copy-6\" transform=\"translate(16.000000, 290.000000)\">\n                <circle id=\"Oval\" cx=\"300\" cy=\"47\" r=\"11\"></circle>\n            </g>\n        </g>\n    </g>\n</svg>",
                styles: [""]
            }] }
];
/** @nocollapse */
EmptyCircleComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/filters/filters.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FiltersComponent {
    constructor() {
        this.facets = [];
        this.selectedFilter = new EventEmitter();
        this.FilterType = FilterType;
        this.formattedFacets = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.formatFacets();
    }
    /**
     * @return {?}
     */
    formatFacets() {
        this.facets.forEach((/**
         * @param {?} facet
         * @param {?} index
         * @return {?}
         */
        (facet, index) => {
            /** @type {?} */
            let facetObj = {};
            facetObj['name'] = facet['name'];
            facetObj['type'] = this.config[facet['name']] && this.config[facet['name']]['type'] ? this.config[facet['name']]['type'] : 'dropdown';
            facetObj['index'] = this.config[facet['name']] && this.config[facet['name']]['index'] ? this.config[facet['name']]['index'] : index;
            facetObj['label'] = this.config[facet['name']] && this.config[facet['name']]['label'] ? this.config[facet['name']]['label'] : facet['name'];
            facetObj['placeHolder'] = this.config[facet['name']] && this.config[facet['name']]['placeHolder'] ? this.config[facet['name']]['placeHolder'] : 'Select ' + facet['name'];
            facetObj['default'] = this.config[facet['name']] && this.config[facet['name']]['default'] ? this.config[facet['name']]['default'] : '';
            facetObj['data'] = [];
            facet['values'].forEach((/**
             * @param {?} facetValue
             * @return {?}
             */
            facetValue => {
                facetObj['data'].push({
                    label: facetValue['name'],
                    value: facetValue['name']
                });
            }));
            this.formattedFacets.push(facetObj);
            this.formattedFacets.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => a.index - b.index));
        }));
    }
}
FiltersComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-filters',
                template: "<div *ngIf=\"type === FilterType.FACET\">\n  <div *ngFor=\"let facet of formattedFacets\">\n\n    <!-- Start of Dropdown -->\n    <sb-dropdown *ngIf=\"facet.type === 'dropdown'\" [type]=\"type\" [label]=\"facet.label\" [options]=\"facet\"\n      [placeHolder]=\"facet.placeHolder\" [default]=\"facet.default\" [styleClass]=\"styleClass\"\n      (onChangeFilter)=\"selectedFilter.emit($event)\">\n    </sb-dropdown>\n    <!-- End of Dropdown -->\n\n    <!-- Start of pills -->\n    <div *ngIf=\"facet.type === 'pills'\">\n      <sb-pills [label]=\"facet.label\" [options]=\"facet\" [styleClass]=\"styleClass\"\n        (onChangeFilter)=\"selectedFilter.emit($event)\"></sb-pills>\n    </div>\n    <!-- End of pills -->\n\n  </div>\n</div>",
                styles: [""]
            }] }
];
/** @nocollapse */
FiltersComponent.ctorParameters = () => [];
FiltersComponent.propDecorators = {
    type: [{ type: Input }],
    facets: [{ type: Input }],
    config: [{ type: Input }],
    styleClass: [{ type: Input }],
    selectedFilter: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pills/pills.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PillsComponent {
    constructor() {
        this.options = [];
        this.onChangeFilter = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} selectedValue
     * @return {?}
     */
    onChangeFacet(selectedValue) {
        /** @type {?} */
        let emitPayload = JSON.parse(JSON.stringify(this.options));
        emitPayload['data'] = selectedValue;
        emitPayload['selectedLabel'] = selectedValue.label;
        emitPayload['selectedValue'] = selectedValue.value;
        this.onChangeFilter.emit(emitPayload);
    }
}
PillsComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-pills',
                template: "<div class=\"sbt-class-bar\">\n  <label>{{label}}</label>\n  <div class=\"sb-slider-pills-container\">\n    <div class=\"sb-pills-container sb-grade-pills-container\" id=\"gradeScroll\">\n      <div class=\"pill rounded\" *ngFor=\"let facet of options.data; let i = index;\" [ngClass]=\"((options.default === facet.value ? 'active' : '')  + ' ' + styleClass)\"\n      attr.id=\"class{{i}}\" (click)=\"onChangeFacet(facet)\">\n      {{facet.value}}\n      </div>\n    </div>\n  </div>\n</div>\n",
                styles: [".sbt-class-bar .sb-slider-pills-container{overflow-x:inherit!important}.sbt-class-bar .sb-slider-pills-container .sb-grade-pills-container{background:inherit!important;padding-top:0!important}.sbt-class-bar .sb-slider-pills-container .sb-pills-container{display:-webkit-box!important;display:flex!important;flex-wrap:wrap;-webkit-box-pack:start;justify-content:flex-start;margin:0 -8px 0 0}html[dir=rtl] .sbt-class-bar .sb-slider-pills-container .sb-pills-container{margin:0 0 0 -8px!important}.sbt-class-bar .sb-slider-pills-container .sb-pills-container .pill{padding:8px 16px!important;color:#fff!important;margin:0 8px 8px 0!important;background-color:#07f;font-size:12px!important;display:unset!important;width:100px;flex-basis:100px;-webkit-box-flex:1;flex-grow:1}html[dir=rtl] .sbt-class-bar .sb-slider-pills-container .sb-pills-container .pill{margin:0 0 8px 8px!important}.sbt-class-bar .sb-slider-pills-container .sb-pills-container .pill.active,.sbt-class-bar .sb-slider-pills-container .sb-pills-container .pill:hover{color:#fff!important;background-color:#0076fe!important;box-shadow:rgba(0,0,0,.1) 3px 3px 2px 0}.sb-slider-pills-container{overflow-x:auto}.sb-slider-pills-container .sb-pills-container{display:-webkit-inline-box;display:inline-flex;-webkit-box-align:center;align-items:center;box-sizing:border-box}.sb-slider-pills-container .sb-pills-container .pill{background-color:#fff;white-space:nowrap;-webkit-appearance:none;text-overflow:ellipsis;min-height:32px;cursor:pointer;-webkit-transition:.25s ease-in-out;transition:.25s ease-in-out;border-radius:2px;text-transform:capitalize;text-decoration:none;text-align:center;font-weight:400;font-style:normal;font-stretch:normal;font-size:12px;box-sizing:border-box;display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;line-height:16px}.sb-slider-pills-container .sb-medium-pills-container{min-height:64px;background:#fff;min-width:100%}.sb-slider-pills-container .sb-medium-pills-container .pill{border:1px solid #008840;color:#008840}.sb-slider-pills-container .sb-medium-pills-container .pill.active,.sb-slider-pills-container .sb-medium-pills-container .pill:active,.sb-slider-pills-container .sb-medium-pills-container .pill:hover{color:#fff;background-color:#008840;box-shadow:0 3px 4px 0 rgba(0,0,0,)}.sb-slider-pills-container .sb-grade-pills-container{min-height:48px;min-width:100%}.sb-slider-pills-container .sb-grade-pills-container .pill{border-radius:16px;color:#024f9d;min-height:32px}.sb-slider-pills-container .sb-grade-pills-container .pill.active,.sb-slider-pills-container .sb-grade-pills-container .pill:active,.sb-slider-pills-container .sb-grade-pills-container .pill:hover{background-color:#024f9d;color:#fff;box-shadow:0 3px 4px 0 rgba(0,0,0,)}.sb-slider-pills-container .sb-grade-pills-container .pill.active .icon-svg svg,.sb-slider-pills-container .sb-grade-pills-container .pill:active .icon-svg svg,.sb-slider-pills-container .sb-grade-pills-container .pill:hover .icon-svg svg{fill:#fff}.sb-slider-pills-container .sb-grade-pills-container .pill.rounded{font-size:14px}.sb-slider-pills-container .sb-grade-pills-container .pill.rounded-with-icon .icon-svg{margin-right:4px;top:0}html[dir=rtl] .sb-slider-pills-container .sb-grade-pills-container .pill.rounded-with-icon .icon-svg{margin-left:4px;margin-right:inherit}.sb-slider-pills-container .sb-grade-pills-container .pill.rounded-with-icon .name{-ms-grid-row-align:center;align-self:center;display:inline-block;line-height:16px}"]
            }] }
];
/** @nocollapse */
PillsComponent.ctorParameters = () => [];
PillsComponent.propDecorators = {
    options: [{ type: Input }],
    label: [{ type: Input }],
    styleClass: [{ type: Input }],
    onChangeFilter: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/dynamic-form/dynamic-form.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicFormComponent {
    /**
     * @param {?} formBuilder
     */
    constructor(formBuilder) {
        this.formBuilder = formBuilder;
        this.initialize = new EventEmitter();
        this.finalize = new EventEmitter();
        this.dataLoadStatusDelegate = new Subject();
        this.valueChanges = new EventEmitter();
        this.statusChanges = new EventEmitter();
        this._ = _;
        this.FieldConfigInputType = FieldConfigInputType;
        this.isSection = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const formGroupData = {};
        /** @type {?} */
        const dependency = [];
        if (changes['config']) {
            if ((changes['config'].currentValue && changes['config'].firstChange)
                || changes['config'].previousValue !== changes['config'].currentValue) {
                this.initialize.emit(this.formGroup);
            }
        }
        if (this.statusChangesSubscription) {
            this.statusChangesSubscription.unsubscribe();
        }
        if (this.valueChangesSubscription) {
            this.valueChangesSubscription.unsubscribe();
        }
        this.isSection = !isEmpty(find(this.config, 'fields'));
        if (this.isSection) {
            this.config.forEach((/**
             * @param {?} sections
             * @return {?}
             */
            (sections) => {
                sections.fields.forEach((/**
                 * @param {?} element
                 * @param {?} index
                 * @return {?}
                 */
                (element, index) => {
                    /** @type {?} */
                    const formValueList = this.prepareFormValidationData(element, index);
                    if (!isEmpty(element.depends)) {
                        dependency.push({ code: element.code, depends: element.depends });
                    }
                    formGroupData[element.code] = formValueList;
                }));
            }));
        }
        else {
            /** @type {?} */
            let defaultSection = [];
            defaultSection = [
                {
                    'name': '',
                    'fields': cloneDeep(this.config)
                }
            ];
            this.config = cloneDeep(defaultSection);
            defaultSection.forEach((/**
             * @param {?} sections
             * @return {?}
             */
            (sections) => {
                sections.fields.forEach((/**
                 * @param {?} element
                 * @param {?} index
                 * @return {?}
                 */
                (element, index) => {
                    /** @type {?} */
                    const formValueList = this.prepareFormValidationData(element, index);
                    if (!isEmpty(element.depends)) {
                        dependency.push({ code: element.code, depends: element.depends });
                    }
                    formGroupData[element.code] = formValueList;
                }));
            }));
        }
        this.flattenSectionFields = this.getFlattenedSectionFields();
        this.formGroup = this.formBuilder.group(formGroupData);
        this.statusChangesSubscription = this.formGroup.valueChanges.pipe(tap((/**
         * @param {?} v
         * @return {?}
         */
        (v) => {
            this.statusChanges.emit({
                isPristine: this.formGroup.pristine,
                isDirty: this.formGroup.dirty,
                isInvalid: this.formGroup.invalid,
                isValid: this.formGroup.valid,
                controls: this.getFormValidationErrors()
            });
        }))).subscribe();
        this.valueChangesSubscription = this.formGroup.valueChanges.pipe(tap((/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            this.valueChanges.emit(data);
        }))).subscribe();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.finalize.emit();
        if (this.statusChangesSubscription) {
            this.statusChangesSubscription.unsubscribe();
        }
        if (this.valueChangesSubscription) {
            this.valueChangesSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    getFormValidationErrors() {
        /** @type {?} */
        const errors = [];
        keys(this.formGroup.controls).forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            /** @type {?} */
            const controlErrors = this.formGroup.get(key).errors;
            if (controlErrors != null) {
                keys(controlErrors).forEach((/**
                 * @param {?} keyError
                 * @return {?}
                 */
                keyError => {
                    errors.push({
                        control_name: key,
                        error_name: keyError,
                        error_value: controlErrors[keyError]
                    });
                }));
            }
        }));
        return errors;
    }
    /**
     * @private
     * @param {?} element
     * @param {?} index
     * @return {?}
     */
    prepareFormValidationData(element, index) {
        /** @type {?} */
        const formValueList = [];
        /** @type {?} */
        const validationList = [];
        /** @type {?} */
        let defaultVal = '';
        switch (element.inputType) {
            case 'text':
                defaultVal = element.default || null;
                break;
            case 'textarea':
                defaultVal = element.default || null;
                break;
            case 'select':
                if (element.default) {
                    if (element.dataType === 'list') {
                        if (isArray(element.default)) {
                            defaultVal = element.default;
                        }
                        else {
                            defaultVal = toArray(element.default);
                        }
                    }
                    else if (element.dataType === 'text') {
                        if (isString(element.default)) {
                            defaultVal = element.default;
                        }
                        else {
                            defaultVal = toString(element.default);
                        }
                    }
                }
                else {
                    defaultVal = null;
                }
                break;
            case 'multiselect':
                if (element.default) {
                    if (element.dataType === 'list' && isArray(element.default)) {
                        defaultVal = element.default;
                    }
                    else if (element.dataType === 'list' && isString(element.default)) {
                        if (includes(element.default, ',')) {
                            defaultVal = split(element.default, ',');
                        }
                        else {
                            defaultVal = [element.default];
                        }
                    }
                    else if (element.dataType === 'text') {
                        if (includes(element.default, ',')) {
                            defaultVal = split(element.default, ',');
                        }
                        else {
                            defaultVal = [element.default];
                        }
                    }
                }
                else {
                    defaultVal = [];
                }
                break;
            case 'nestedselect':
                defaultVal = element.dataType === 'list' ?
                    (element.default && Array.isArray(element.default) ? element.default :
                        isEmpty(element.default) ? [] : [element.default]) :
                    (element.default || null);
                break;
            case 'checkbox':
                defaultVal = (element.dataType === 'text') ? (element.default === 'Yes' ? 'Yes' : 'No') : !!element.default;
                break;
        }
        formValueList.push(defaultVal);
        if (element.validations && element.validations.length) {
            element.validations.forEach((/**
             * @param {?} data
             * @param {?} i
             * @return {?}
             */
            (data, i) => {
                switch (data.type) {
                    case 'required':
                        if (element.inputType === 'select' || element.inputType === 'multiselect' || element.inputType === 'nestedselect') {
                            validationList.push(Validators.required);
                        }
                        else if (element.type === 'checkbox') {
                            validationList.push(Validators.requiredTrue);
                        }
                        else {
                            validationList.push(Validators.required);
                        }
                        break;
                    case 'pattern':
                        validationList.push(Validators.pattern((/** @type {?} */ (element.validations[i].value))));
                        break;
                    case 'min':
                        validationList.push(Validators.minLength((/** @type {?} */ (element.validations[i].value))));
                        break;
                    case 'max':
                        validationList.push(Validators.maxLength((/** @type {?} */ (element.validations[i].value))));
                        break;
                }
            }));
        }
        formValueList.push(Validators.compose(validationList));
        return formValueList;
    }
    /**
     * @param {?} config
     * @param {?} context
     * @return {?}
     */
    fetchContextTerms(config, context) {
        return get(find(config, { 'code': context }), 'terms') || null;
    }
    /**
     * @param {?} code
     * @param {?} depends
     * @return {?}
     */
    getAllDependsFormControl(code, depends) {
        /** @type {?} */
        const fieldDepends = {};
        forEach(depends, (/**
         * @param {?} depend
         * @return {?}
         */
        depend => {
            if (this.formGroup.get(depend)) {
                fieldDepends[depend] = this.formGroup.get(depend);
            }
        }));
        return fieldDepends || null;
    }
    /**
     * @param {?} code
     * @param {?} depends
     * @return {?}
     */
    fetchDependencyTerms(code, depends) {
        /** @type {?} */
        const dependsTerms = map$1(filter(this.flattenSectionFields, (/**
         * @param {?} c
         * @return {?}
         */
        c => {
            return includes(depends, c.code);
        })), (/**
         * @param {?} depend
         * @return {?}
         */
        (depend) => {
            return depend.terms || depend.range;
        }));
        return flatten(dependsTerms);
    }
    /**
     * @param {?} config
     * @param {?} val
     * @return {?}
     */
    getAppIcon(config, val) {
        if (val) {
            return config.filter((/**
             * @param {?} field
             * @return {?}
             */
            field => {
                return field.code === 'appicon';
            }));
        }
        else {
            return config.filter((/**
             * @param {?} field
             * @return {?}
             */
            field => {
                return field.code !== 'appicon';
            }));
        }
    }
    /**
     * @param {?} config
     * @return {?}
     */
    groupBySection(config) {
        /** @type {?} */
        const fields = this.getAppIcon(config, false);
        return groupBy(fields, 'section.index');
    }
    /**
     * @return {?}
     */
    getFlattenedSectionFields() {
        return flatten(map$1(this.config, 'fields'));
    }
}
DynamicFormComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-dynamic-form',
                template: "\n<div class=\"dynamic-form\" [formGroup]=\"formGroup\">\n  <div *ngFor=\"let section of config\" class=\"formSection grid two-column-grid\">\n      <ng-container *ngFor=\"let field of section['fields']\" sbDynamicField\n      [depends]=\"getAllDependsFormControl(field.code, field.depends)\" [dependencyTerms]=\"field.depends ? fetchDependencyTerms(field.code, field.depends) : []\"\n      [context]=\"field.context ? formGroup.get(field.context) : null\" [contextTerms]=\"fetchContextTerms(config, field.context)\"\n      [options]=\"field.terms\" [field]=\"field\" [formGroup]=\"formGroup\" [default]=\"field.default || ''\" [label]=\"field.label\" [formControlRef]=\"formGroup.get(field.code)\"\n      [dataLoadStatusDelegate]=\"dataLoadStatusDelegate\" [placeholder]=\"field.placeholder || ''\" [validations]=\"field.validations || []\"\n      [disabled]=\"field.editable === true ? false : true\">\n    </ng-container>\n  </div>\n</div>\n\n",
                styles: [""]
            }] }
];
/** @nocollapse */
DynamicFormComponent.ctorParameters = () => [
    { type: FormBuilder }
];
DynamicFormComponent.propDecorators = {
    config: [{ type: Input }],
    initialize: [{ type: Output }],
    finalize: [{ type: Output }],
    dataLoadStatusDelegate: [{ type: Input }],
    valueChanges: [{ type: Output }],
    statusChanges: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/dynamic-textbox/dynamic-textbox.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicTextboxComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.asyncValidation && this.asyncValidation.asyncValidatorFactory && this.formControlRef) {
            if (this.formControlRef.asyncValidator) {
                return;
            }
            this.formControlRef.setAsyncValidators(this.asyncValidation.asyncValidatorFactory(this.asyncValidation.marker, this.validationTrigger.nativeElement));
        }
    }
}
DynamicTextboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-dynamic-textbox',
                template: "<div class=\"sb-input\">\n  <label *ngIf=\"label\">{{label}}</label>\n  <!-- <div *ngIf=\"labelHtml\" [innerHTML]=\"labelHtml | transposeHtml\"></div> -->\n\n  <div [ngClass]=\"{'async-text': (asyncValidation && asyncValidation?.trigger), '': (!asyncValidation || !asyncValidation?.trigger)}\">\n    <div class=\"prefix\" *ngIf=\"prefix\">\n      <span>{{prefix}}</span>\n    </div>\n    <input [formControl]=\"formControlRef\" [class.valid]=\"formControlRef.valid &&\n    (formControlRef.dirty || formControlRef.touched)\"\n[class.invalid]=\"formControlRef.invalid &&\n(formControlRef.dirty || formControlRef.touched)\" class=\"sb-textbox {{disabled}}\" placeholder={{placeholder}} type=\"text\"\n[attr.disabled]=\"disabled ? true : null\">\n    <div class=\"async-icons\" *ngIf=\"asyncValidation && asyncValidation?.trigger\">\n      <!-- <sb-green-tick *ngIf=\"formControlRef.value && formControlRef.status === 'VALID'\"></sb-green-tick> -->\n      <!-- <sb-red-exclamation *ngIf=\"formControlRef.value && formControlRef.status !== 'VALID'\"></sb-red-exclamation> -->\n      <!-- <sb-empty-circle *ngIf=\"!formControlRef.value\"></sb-empty-circle> -->\n    </div>\n  </div>\n\n  <ng-container *ngFor=\"let validation of validations\">\n    <div class=\"cf-error\"\n      *ngIf=\"(validation.type && (validation.type).toLowerCase() && validation.message && formControlRef.errors && formControlRef.errors[(validation.type).toLowerCase()] && (formControlRef.dirty || formControlRef.touched))\">\n      {{ validation.message }}\n    </div>\n  </ng-container>\n\n  <ng-container *ngIf=\"asyncValidation?.trigger\">\n    <div class=\"async-validator\"\n      [hidden]=\"formControlRef.status === 'VALID' || formControlRef.status !== 'PENDING' || !formControlRef.value\">\n      <div class=\"cf-error\" *ngIf=\"asyncValidation?.message\">\n        {{ asyncValidation.message }}\n      </div>\n      <div class=\"async-container\">\n        <button class=\"async-btn\" #validationTrigger [attr.data-marker]=\"asyncValidation.marker\">\n          {{asyncValidation.trigger}}\n        </button>\n      </div>\n    </div>\n  </ng-container>\n\n</div>\n",
                styles: ["label{display:block;font-size:1rem;margin:0}.sb-textbox{width:100%;padding:8px 16px;border:.5px solid #333;box-sizing:border-box}::-webkit-input-placeholder{padding:.25rem;opacity:.99;color:#999;font-family:\"Noto Sans\";font-size:12px;font-weight:700}::-moz-placeholder{padding:.25rem;opacity:.99;color:#999;font-family:\"Noto Sans\";font-size:12px;font-weight:700}:-ms-input-placeholder{padding:.25rem;opacity:.99;color:#999;font-family:\"Noto Sans\";font-size:12px;font-weight:700}::-ms-input-placeholder{padding:.25rem;opacity:.99;color:#999;font-family:\"Noto Sans\";font-size:12px;font-weight:700}::placeholder{padding:.25rem;opacity:.99;color:#999;font-family:\"Noto Sans\";font-size:12px;font-weight:700}.sb-input{margin:1rem 0}.cf-error{color:red;font-family:\"Noto Sans\";font-size:12px}.async-container{text-align:center}.async-btn{padding:12px 16px;background-color:#008840;color:#fff;border-radius:20px!important}.async-text{display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;border:.5px solid #333}.async-text>input{border:none}.normal-text>.async-icons>sb-empty-circle,.normal-text>.async-icons>sb-green-tick,.normal-text>.async-icons>sb-red-exclamation{display:none}.prefix{white-space:nowrap;padding:0 4px}.async-icons{margin:auto;padding:0 4px}"]
            }] }
];
/** @nocollapse */
DynamicTextboxComponent.ctorParameters = () => [];
DynamicTextboxComponent.propDecorators = {
    asyncValidation: [{ type: Input }],
    label: [{ type: Input }],
    labelHtml: [{ type: Input }],
    placeholder: [{ type: Input }],
    validations: [{ type: Input }],
    formControlRef: [{ type: Input }],
    prefix: [{ type: Input }],
    default: [{ type: Input }],
    disabled: [{ type: Input }],
    validationTrigger: [{ type: ViewChild, args: ['validationTrigger', { static: false },] }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/dynamic-textarea/dynamic-textarea.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicTextareaComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const maxLengthValidation = this.field.validations &&
            this.field.validations.find((/**
             * @param {?} validation
             * @return {?}
             */
            (validation) => validation.type === FieldConfigValidationType.MAXLENGTH));
        if (maxLengthValidation) {
            this.remainderValidLength$ = this.formControlRef.valueChanges.pipe(startWith(''), map((/**
             * @param {?} v
             * @return {?}
             */
            (v) => ((typeof maxLengthValidation.value === 'number') ? maxLengthValidation.value : 0) - (v || '').length)));
        }
    }
}
DynamicTextareaComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-dynamic-textarea',
                template: "<div class=\"sb-textarea-container\">\n  <label>{{label}}</label>\n  <textarea class=\"sb-textarea\" [formControl]=\"formControlRef\" rows=\"5\" name=\"sb-textarea\" placeholder={{placeholder}} [attr.disabled]=\"disabled ? true : null\">\n  </textarea>\n  <div class=\"remaining-length\" *ngIf=\"remainderValidLength$\">\n     {{remainderValidLength$ | async}} Characters left\n  </div>\n  <ng-container *ngFor=\"let validation of validations\">\n    <div class=\"cf-error\"\n      *ngIf=\"(validation.type && (validation.type).toLowerCase() && validation.message && formControlRef.errors && formControlRef.errors[(validation.type).toLowerCase()] && (formControlRef.dirty || formControlRef.touched))\">\n      {{ validation.message }}\n    </div>\n  </ng-container>\n</div>\n",
                styles: ["label{display:block;padding:8px 0 0;font-size:14px}.sb-textarea{width:100%;padding:8px;box-sizing:border-box;border:1px solid #ccc;border-radius:.25rem;resize:vertical}.sb-textarea-container{margin-bottom:10px;position:relative}.remaining-length{position:absolute;bottom:.5rem;right:1rem;font-size:10px;color:#999}::-webkit-input-placeholder{padding:.25rem;color:#999;font-family:\"Noto Sans\";font-size:14px;letter-spacing:0;line-height:20px}::-moz-placeholder{padding:.25rem;color:#999;font-family:\"Noto Sans\";font-size:14px;letter-spacing:0;line-height:20px}:-ms-input-placeholder{padding:.25rem;color:#999;font-family:\"Noto Sans\";font-size:14px;letter-spacing:0;line-height:20px}::-ms-input-placeholder{padding:.25rem;color:#999;font-family:\"Noto Sans\";font-size:14px;letter-spacing:0;line-height:20px}::placeholder{padding:.25rem;color:#999;font-family:\"Noto Sans\";font-size:14px;letter-spacing:0;line-height:20px}.cf-error{color:red;font-family:\"Noto Sans\";font-size:12px}"]
            }] }
];
/** @nocollapse */
DynamicTextareaComponent.ctorParameters = () => [];
DynamicTextareaComponent.propDecorators = {
    label: [{ type: Input }],
    placeholder: [{ type: Input }],
    formControlRef: [{ type: Input }],
    field: [{ type: Input }],
    validations: [{ type: Input }],
    default: [{ type: Input }],
    disabled: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/dynamic-dropdown/dynamic-dropdown.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicDropdownComponent {
    constructor() {
        this.ValueComparator = ValueComparator;
        this.onChangeFilter = new EventEmitter();
        this.dependencyTerms = [];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.options) {
            this.options = [];
        }
        if (this.isOptionsClosure(this.options)) {
            this.options$ = (/** @type {?} */ (((/** @type {?} */ (this.options)))(this.formControlRef, this.depends, this.formGroup, (/**
             * @return {?}
             */
            () => this.dataLoadStatusDelegate.next('LOADING')), (/**
             * @return {?}
             */
            () => this.dataLoadStatusDelegate.next('LOADED')))));
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.options) {
            this.options = [];
        }
        // if (this.context) {
        // this.contextValueChangesSubscription = this.context.valueChanges.pipe(
        //   tap(() => {
        //     this.formControlRef.patchValue(null);
        //   })
        // ).subscribe();
        // }
        this.dataLoadStatusDelegate.subscribe(console.log);
        if (this.field && this.field.range) {
            this.options = this.field.range;
        }
        else if (isEmpty(this.options) && isEmpty(this.field.range) && this.default) {
            this.field.range = [];
            this.field.range.push(this.default);
        }
        if (!isEmpty(this.depends)) {
            this.contextValueChangesSubscription = merge(...map$1(this.depends, (/**
             * @param {?} depend
             * @return {?}
             */
            depend => depend.valueChanges))).pipe(tap((/**
             * @param {?} value
             * @return {?}
             */
            (value) => {
                this.latestParentValue = value;
                this.isDependsInvalid = includes(map$1(this.depends, (/**
                 * @param {?} depend
                 * @return {?}
                 */
                depend => depend.invalid)), true);
                this.formControlRef.patchValue(null);
            }))).subscribe();
            this.isDependsInvalid = includes(map$1(this.depends, (/**
             * @param {?} depend
             * @return {?}
             */
            depend => depend.invalid)), true);
        }
        if (this.isOptionsClosure(this.options)) {
            // tslint:disable-next-line:max-line-length
            this.options$ = (/** @type {?} */ (((/** @type {?} */ (this.options)))(this.formControlRef, this.depends, this.formGroup, (/**
             * @return {?}
             */
            () => this.dataLoadStatusDelegate.next('LOADING')), (/**
             * @return {?}
             */
            () => this.dataLoadStatusDelegate.next('LOADED')))));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.contextValueChangesSubscription) {
            this.contextValueChangesSubscription.unsubscribe();
        }
    }
    /**
     * @param {?} options
     * @return {?}
     */
    isOptionsArray(options) {
        return Array.isArray(options);
    }
    /**
     * @param {?} options
     * @return {?}
     */
    isOptionsClosure(options) {
        return typeof options === 'function';
    }
    /**
     * @param {?} input
     * @return {?}
     */
    isOptionsMap(input) {
        return !Array.isArray(input) && typeof input === 'object';
    }
    /**
     * @param {?} input
     * @return {?}
     */
    isOptionsArrayMap(input) {
        return Array.isArray(input) && typeof input[0] === 'object';
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onChangeFacet($event) {
        /** @type {?} */
        const selectedObject = this.options.data[$event.currentTarget.options.selectedIndex - 1];
        /** @type {?} */
        const emitPayload = JSON.parse(JSON.stringify(this.options));
        emitPayload['data'] = selectedObject;
        emitPayload['selectedLabel'] = selectedObject.label;
        emitPayload['selectedValue'] = selectedObject.value;
        this.onChangeFilter.emit(emitPayload);
    }
    /**
     * @return {?}
     */
    fetchAssociations() {
        // && this.context.value && this.field.association
        if (!isEmpty(this.depends)) {
            /** @type {?} */
            const filteredTerm = find(this.dependencyTerms, (/**
             * @param {?} terms
             * @return {?}
             */
            terms => {
                return !isEmpty(this.field.output) ?
                    includes(this.getParentValue(), terms[this.field.output]) :
                    includes(this.getParentValue(), terms.name);
            }));
            if (filteredTerm) {
                this.tempAssociation = filter(filteredTerm.associations, (/**
                 * @param {?} association
                 * @return {?}
                 */
                association => {
                    return (this.field.sourceCategory) ?
                        (association.category === this.field.sourceCategory) :
                        association.category === this.field.code;
                }));
                return this.tempAssociation;
            }
            else {
                return this.options;
            }
        }
        else {
            return this.options;
        }
    }
    /**
     * @return {?}
     */
    getParentValue() {
        return this.latestParentValue || compact(map$1(this.depends, 'value'));
    }
    /**
     * @param {?} option
     * @return {?}
     */
    getOptionValueForTerms(option) {
        if (this.field.output) {
            if (this.field.dataType === 'list') {
                return [option[this.field.output]];
            }
            return option[this.field.output];
        }
        else {
            return this.field.dataType === 'list' ? [option.name] : option.name;
        }
    }
    /**
     * @param {?} option
     * @param {?} optionsType
     * @return {?}
     */
    getOptionValueForRange(option, optionsType) {
        if (this.field.output) {
            if (this.field.dataType === 'list') {
                if (optionsType === 'map' || optionsType === 'closure') {
                    return [option[this.field.output]] || [option.value] || [option.identifier] || [option.name] || [option.label];
                }
                else {
                    return [option];
                }
            }
            else {
                if (optionsType === 'map' || optionsType === 'closure') {
                    return option[this.field.output] || option.value || option.identifier || option.name || option.label;
                }
                else {
                    return option;
                }
            }
        }
        else {
            if (this.field.dataType === 'list') {
                if (optionsType === 'map' || optionsType === 'closure') {
                    return [option.value] || [option.identifier] || [option.name] || [option.label];
                }
                else {
                    return [option];
                }
            }
            else {
                if (optionsType === 'map' || optionsType === 'closure') {
                    return option.name || option.label || option.value || option.identifier;
                }
                else {
                    return option;
                }
            }
        }
    }
    /**
     * @param {?} option
     * @param {?=} output
     * @return {?}
     */
    convertOptionToArray(option, output) {
    }
}
DynamicDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-dynamic-dropdown',
                template: "<div class=\"sb-dropdown\" *ngIf=\"!type\">\n  <label>{{label}} {{context && 'has context'}}  {{context ?  field.context : '' }}</label>\n  <ng-container *ngIf=\"options\">\n    <div class=\"dropdown-container\">\n      <sb-icon-dropdown class=\"dropdown-icon\"></sb-icon-dropdown>\n      <!-- [attr.disabled]=\"disabled ? true : ( context ? (context.invalid ? true : null) : null )\" -->\n      <select [formControl]=\"formControlRef\"\n              [attr.disabled]=\"disabled ? true : ( depends ? (isDependsInvalid ? true : null) : null )\"\n              [compareWith]=\"ValueComparator.valueComparator\" class=\"sb-dropdown-select\" id=\"sb-dropdown\"\n              name=\"sb-dropdown\">\n        <option [defaultSelected]=\"!default\" [ngValue]=\"null\" disabled>{{placeholder}}\n        </option>\n        <ng-container *ngIf=\"field.range && isOptionsArrayMap(field.range) && !field.association\">\n          <option class=\"optionsArrayMap\" *ngFor=\"let option of field.range\" [ngValue]=\"getOptionValueForRange(option, 'map')\">{{option.label}}</option>\n        </ng-container>\n        <ng-container *ngIf=\"field.range && isOptionsArray(field.range) && !isOptionsArrayMap(field.range) && !field.association\">\n          <option class=\"optionsArray\" *ngFor=\"let option of field.range\" [ngValue]=\"getOptionValueForRange(option, 'array')\">{{option.name || option}}</option>\n        </ng-container>\n\n        <ng-container *ngIf=\"field.range && isOptionsClosure(field.range)\">\n          <option class=\"closure\" *ngFor=\"let option of options$ | async\" [ngValue]=\"getOptionValueForRange(option, 'closure')\">{{option.label}}</option>\n        </ng-container>\n\n        <!-- <ng-container *ngIf=\"isOptionsMap(options) && context && context.value && !field.association\">\n          <option *ngFor=\"let option of options[context.value]\" [ngValue]=\"option.value\">{{option.label}}</option>\n        </ng-container> -->\n\n        <ng-container *ngIf=\"!field.range && field.terms\">\n          <option class=\"optionsLast\" *ngFor=\"let option of fetchAssociations()\" [ngValue]=\"getOptionValueForTerms(option)\">{{option.name}}</option>\n        </ng-container>\n      </select>\n    </div>\n  </ng-container>\n</div>\n\n<!-- Dropdown for filters component -->\n<div class=\"sb-dropdown\" *ngIf=\"type === 'facet'\">\n  <label>{{label}}</label>\n  <ng-container *ngIf=\"options && options.data\">\n    <div class=\"dropdown-container\">\n      <sb-icon-dropdown class=\"dropdown-icon\"></sb-icon-dropdown>\n      <select [attr.disabled]=\"disabled ? true : ( context ? (context.invalid ? true : null) : null )\"\n        class=\"sb-dropdown-select\" [ngClass]=\"(styleClass ? styleClass : 'default-dropdown')\" id=\"sb-dropdown\" name=\"sb-dropdown\"\n        (change)=\"onChangeFacet($event)\" placeholder=\"placeholder\">\n        <option *ngIf=\"!default\" [disabled]=\"true\" selected>{{placeholder}}</option>\n        <option *ngFor=\"let option of options.data\" [ngValue]=\"option\" [selected]=\"options.default === option.value\">{{option.label}}</option>\n      </select>\n    </div>\n  </ng-container>\n</div>\n<ng-container *ngFor=\"let validation of validations\">\n  <div class=\"cf-error\"\n    *ngIf=\"(validation.type && (validation.type).toLowerCase() && validation.message && formControlRef.errors && formControlRef.errors[(validation.type).toLowerCase()] && (formControlRef.dirty || formControlRef.touched))\">\n    {{ validation.message }}\n  </div>\n</ng-container>\n\n<!-- Dropdown for filters component -->\n",
                styles: ["label{display:block;padding:10px;font-size:1rem}.dropdown-icon{position:absolute;top:.5rem;right:18px;z-index:1}.dropdown-container{position:relative}select[disabled]{opacity:.3}select{-webkit-appearance:none;-moz-appearance:none;text-indent:1px;text-overflow:''}.sb-dropdown-select{opacity:.99;color:#333;font-family:\"Noto Sans\";font-size:12px;font-weight:700;letter-spacing:0;line-height:17px}.sb-dropdown{margin-bottom:8px}.placeholder select option:first-child{color:#999}.option-default{color:#333;font-weight:700;font-size:12px}.sb-dropdown select{background-color:#fff;padding:10px 20px;font-size:14px;width:100%;border:.5px solid #333}.cf-error{color:red;font-family:\"Noto Sans\";font-size:12px}"]
            }] }
];
/** @nocollapse */
DynamicDropdownComponent.ctorParameters = () => [];
DynamicDropdownComponent.propDecorators = {
    field: [{ type: Input }],
    disabled: [{ type: Input }],
    options: [{ type: Input }],
    label: [{ type: Input }],
    placeholder: [{ type: Input }],
    isMultiple: [{ type: Input }],
    context: [{ type: Input }],
    contextTerms: [{ type: Input }],
    formControlRef: [{ type: Input }],
    formGroup: [{ type: Input }],
    default: [{ type: Input }],
    contextData: [{ type: Input }],
    dataLoadStatusDelegate: [{ type: Input }],
    type: [{ type: Input }],
    styleClass: [{ type: Input }],
    onChangeFilter: [{ type: Output }],
    validations: [{ type: Input }],
    depends: [{ type: Input }],
    dependencyTerms: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/dynamic-multiple-dropdown/dynamic-multiple-dropdown.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicMultipleDropdownComponent {
    /**
     * @param {?} changeDetectionRef
     */
    constructor(changeDetectionRef) {
        this.changeDetectionRef = changeDetectionRef;
        this.isMultiple = true;
        this.platform = 'web';
        this.dependencyTerms = [];
        this._ = _;
        this.showModal = false;
        this.tempValue = Set();
        this.resolvedOptions = List();
        this.optionValueToOptionLabelMap = Map();
        this.fromJS = fromJS;
        this.dispose$ = new Subject();
    }
    /**
     * @return {?}
     */
    docClick() {
        if (this.showModal) {
            this.showModal = false;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field && this.field.range) {
            this.options = this.field.range;
        }
        if (!isEmpty(this.depends)) {
            merge(...map$1(this.depends, (/**
             * @param {?} depend
             * @return {?}
             */
            depend => depend.valueChanges))).pipe(tap((/**
             * @return {?}
             */
            () => {
                this.formControlRef.patchValue(null);
                this.resetTempValue();
            })), takeUntil(this.dispose$)).subscribe();
            merge(...map$1(this.depends, (/**
             * @param {?} depend
             * @return {?}
             */
            depend => depend.statusChanges))).pipe(tap((/**
             * @return {?}
             */
            () => {
                this.isDependsInvalid = includes(map$1(this.depends, (/**
                 * @param {?} depend
                 * @return {?}
                 */
                depend => depend.invalid)), true);
            })), takeUntil(this.dispose$)).subscribe();
            this.isDependsInvalid = includes(map$1(this.depends, (/**
             * @param {?} depend
             * @return {?}
             */
            depend => depend.invalid)), true);
        }
        this.formControlRef.valueChanges.pipe(tap((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this.setTempValue(value);
            this.changeDetectionRef.detectChanges();
        })), takeUntil(this.dispose$)).subscribe();
        this.setupOptions();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!changes['options'] || !changes['options'].currentValue) {
            return;
        }
    }
    /**
     * @return {?}
     */
    onSubmit() {
        /** @type {?} */
        const finalValue = this.tempValue.toList().toJS();
        this.formControlRef.patchValue(this.isMultiple ? finalValue : finalValue[0]);
        this.formControlRef.markAsDirty();
        this.showModal = false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    openModal(event) {
        if (this.context && this.context.invalid) {
            return;
        }
        if (this.disabled === true || this.isDependsInvalid) {
            return;
        }
        this.setTempValue(this.formControlRef.value);
        /** @type {?} */
        const htmlCollection = document.getElementsByClassName('sb-modal-dropdown-web');
        /** @type {?} */
        const modalElements = Array.from(htmlCollection);
        /** @type {?} */
        const isModalAlreadyOpened = modalElements.some((/**
         * @param {?} element
         * @return {?}
         */
        (element) => element.hidden === false));
        if (this.platform === 'web' && isModalAlreadyOpened && !this.showModal) {
            modalElements.forEach((/**
             * @param {?} item
             * @return {?}
             */
            (item) => {
                item.hidden = true;
            }));
        }
        if (this.platform === 'web' && this.showModal) {
            this.showModal = false;
        }
        else {
            this.showModal = true;
        }
        event.stopPropagation();
    }
    /**
     * @param {?} option
     * @return {?}
     */
    addSelected(option) {
        if (this.isMultiple) {
            if (this.field.output) {
                if (this.tempValue.includes(option.get(this.field.output))) {
                    this.tempValue = this.tempValue.remove(option.get(this.field.output));
                }
                else {
                    this.tempValue = this.tempValue.add(option.get(this.field.output));
                }
            }
            else if (this.tempValue.includes(option.get('name'))) {
                this.tempValue = this.tempValue.remove(option.get('name'));
            }
            else if (this.tempValue.includes(option.get('identifier'))) {
                this.tempValue = this.tempValue.remove(option.get('identifier'));
            }
            else {
                this.tempValue = this.tempValue.add(option.get('name'));
            }
        }
        else {
            if (this.field.output) {
                this.tempValue = this.tempValue.clear();
                this.tempValue = this.tempValue.add(option.get(this.field.output));
            }
            else {
                this.tempValue = this.tempValue.clear();
                this.tempValue = this.tempValue.add(option.get('name'));
            }
        }
    }
    /**
     * @return {?}
     */
    onCancel() {
        this.formControlRef.markAsDirty();
        this.showModal = false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.dispose$.next(null);
        this.dispose$.complete();
    }
    /**
     * @private
     * @return {?}
     */
    isOptionsArray() {
        return Array.isArray(this.options);
    }
    /**
     * @private
     * @return {?}
     */
    isOptionsClosure() {
        return typeof this.options === 'function';
    }
    /**
     * @private
     * @return {?}
     */
    isOptionsMap() {
        return !Array.isArray(this.options) && typeof this.options === 'object';
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    setTempValue(value) {
        if (value) {
            if (Array.isArray(value)) {
                this.tempValue = Set(fromJS(value));
            }
            else {
                this.tempValue = Set(fromJS([value]));
            }
            // this.onSubmit();
        }
    }
    /**
     * @private
     * @return {?}
     */
    resetTempValue() {
        this.tempValue = Set(null);
    }
    /**
     * @private
     * @return {?}
     */
    setupOptions() {
        if (!this.options) {
            this.options = [];
            this.resolvedOptions = this.resolvedOptions.clear();
        }
        if (this.isOptionsArray()) {
            /** @type {?} */
            const optionMap = map$1(this.options, (/**
             * @param {?} option
             * @return {?}
             */
            option => {
                return {
                    identifier: option.value || option.identifier || option.name || option,
                    name: option.label || option.name || option.value || option,
                };
            }));
            this.resolvedOptions = fromJS(optionMap);
        }
        else if (this.isOptionsMap()) {
            this.resolvedOptions = (this.depends) ?
                fromJS(this.options[this.context.value]) :
                this.resolvedOptions;
        }
        else if (this.isOptionsClosure()) {
            from(((/** @type {?} */ (this.options)))(this.formControlRef, this.depends, this.formGroup, (/**
             * @return {?}
             */
            () => this.dataLoadStatusDelegate.next('LOADING')), (/**
             * @return {?}
             */
            () => this.dataLoadStatusDelegate.next('LOADED')))).pipe(tap((/**
             * @param {?=} options
             * @return {?}
             */
            (options = []) => {
                this.resolvedOptions = fromJS(options);
                this.resolvedOptions.forEach((/**
                 * @param {?} option
                 * @return {?}
                 */
                (option) => {
                    /** @type {?} */
                    const value = !isEmpty(this.field.output) ? option.get(this.field.output) :
                        option.get('name') || option.get('identifier') || option.get('value') || option;
                    /** @type {?} */
                    const labelVal = option.get('name') || option.get('label') || option;
                    this.optionValueToOptionLabelMap = this.optionValueToOptionLabelMap.set(value, labelVal);
                }));
                this.setTempValue(this.default);
                this.changeDetectionRef.detectChanges();
            })), takeUntil(this.dispose$)).subscribe();
        }
        this.resolvedOptions.forEach((/**
         * @param {?} option
         * @return {?}
         */
        (option) => {
            /** @type {?} */
            const value = !isEmpty(this.field.output) ? option.get(this.field.output) :
                option.get('name') || option.get('identifier') || option.get('value') || option;
            /** @type {?} */
            const labelVal = option.get('name') || option.get('label') || option;
            this.optionValueToOptionLabelMap = this.optionValueToOptionLabelMap.set(value, labelVal);
        }));
        this.setTempValue(this.default);
    }
}
DynamicMultipleDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-dynamic-multiple-dropdown',
                template: "<div class=\"multi-select-section-app\">\n  <label class=\"input-label\" *ngIf=\"label\">{{label}}</label>\n  <!-- <div *ngIf=\"labelHtml\" [innerHTML]=\"labelHtml | transposeHtml\"></div> -->\n  <div class=\"multi-select-container\">\n    <sb-caret-down class=\"caret-down\" [ngClass]=\"{'disabled': disabled === true ? true : ( depends ? (isDependsInvalid ? true : null) : null ) }\" (click)=\"openModal($event)\" [attr.disabled]=\"disabled ? true : ( depends ? (isDependsInvalid ? true : null) : null )\">\n    </sb-caret-down>\n    <div class=\"list-border\" (click)=\"openModal($event)\">\n      <ul [ngClass]=\"{'disabled': disabled === true ? true : ( depends ? (isDependsInvalid ? true : null) : null ) }\" [attr.disabled]=\"disabled ? true : ( depends ? (isDependsInvalid ? true : null) : null )\">\n        <ng-container *ngIf=\"isMultiple\">\n          <li *ngIf=\"!formControlRef.value || !formControlRef.value?.length\" class=\"placeholder\">{{placeholder}}</li>\n          <ng-container *ngIf=\"formControlRef.value?.length\">\n            <span *ngFor=\"let value of formControlRef.value; let index=index\">\n              {{optionValueToOptionLabelMap.get(fromJS(value))}}\n              <span *ngIf=\"index < formControlRef.value?.length - 1\">,\n              </span>\n            </span>\n          </ng-container>\n        </ng-container>\n\n        <ng-container *ngIf=\"!isMultiple\">\n          <li *ngIf=\"!formControlRef.value\" class=\"placeholder\">{{placeholder}}</li>\n\n          <span *ngIf=\"formControlRef.value\">{{optionValueToOptionLabelMap.get(fromJS(formControlRef.value))}}</span>\n        </ng-container>\n      </ul>\n    </div>\n    <div class=\"sb-modal-container\" *ngIf=\"platform === 'mobile'\" [hidden]=\"!showModal\" (click)=\"showModal=false;\">\n      <div class=\"sb-modal-overlay\">\n        <div class=\"sb-modal\" (click)=\"$event.stopPropagation()\">\n          <div class=\"header\">\n            {{placeholder}}\n          </div>\n          <div class=\"body\">\n            <ul>\n              <li *ngFor=\"let option of resolvedOptions; let i=index\">\n                <div (click)=\"addSelected(option)\" class=\"row\">\n                  <label class=\"container\" style=\"pointer-events: none\">\n                    <input [checked]=\"!_.isEmpty(field.output) ? tempValue.includes(option.get(field.output)) : tempValue.includes(option.get('name'))\" class=\"sb-checkbox\" type=\"checkbox\">\n                    <span class=\"checkmark\"></span>\n                  </label>\n                  <span>{{option.get('name')}}</span>\n                </div>\n              </li>\n            </ul>\n          </div>\n          <div class=\"footer\">\n            <div class=\"sb-form-button\">\n              <button class=\"sb-btn-primary-outline\" (click)=\"onCancel()\">cancel</button>\n            </div>\n            <div class=\"sb-form-button\">\n              <button class=\"sb-btn-primary\" (click)=\"onSubmit()\">submit</button>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n    <div class=\"sb-modal-dropdown-web\" *ngIf=\"platform === 'web'\"  [hidden]=\"!showModal\" (click)=\"showModal=false;\">\n      <ul>\n        <li *ngFor=\"let option of resolvedOptions; let i=index\" [ngClass]=\"{'selected-option': !_.isEmpty(field.output) ? tempValue.includes(option.get(field.output)) : tempValue.includes(option.get('name'))}\">\n          <div (click)=\"addSelected(option); onSubmit()\">\n            <span class=\"cursor-pointer\">{{option.get('name')}}</span>\n          </div>\n        </li>\n      </ul>\n    </div>\n  </div>\n</div>\n",
                styles: [".multi-select-section-app{margin:1rem 0}label{font-size:14px;font-weight:400;margin:0}.multi-select-container{position:relative;margin-bottom:8px}.multi-select-container .caret-down{position:absolute;top:12px;right:19px;z-index:0}.multi-select-container .list-border .placeholder{margin:0;color:var(--gray-100)}.multi-select-container .list-border ul[disabled]{opacity:.3;pointer-events:none}.multi-select-container .list-border ul{list-style-type:none;position:absolute;margin:0;font-size:14px;font-weight:700}.multi-select-container .list-border{border:.5px solid var(--gray-400);padding:1.3rem;cursor:pointer;display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;left:0;height:40px}.multi-select-container .list-border li{float:left;font-size:12px;font-weight:700;margin-left:4px}.multi-select-container .dropdown li{cursor:pointer;padding:8px;border:1px solid var(--white)}.multi-select-container .dropdown ul{list-style-type:none;margin:0;padding:0}.multi-select-container .row{display:-ms-grid;display:grid;-ms-grid-columns:1fr 10fr;grid-template-columns:1fr 10fr;grid-gap:0}.multi-select-container .footer{display:-ms-grid;display:grid;-ms-grid-columns:1fr 1fr;grid-template-columns:1fr 1fr;grid-gap:0;padding-left:8px;padding-bottom:8px;padding-top:8px}.multi-select-container .sb-modal-container{position:fixed;height:100vh;overflow:hidden;width:100%;left:0;top:0;right:0;z-index:10}.multi-select-container .sb-modal-overlay{position:absolute;width:100%;height:100%;top:0;background:rgba(0,0,0,.6);left:0;z-index:10}.multi-select-container .fa .fa-close{float:right}.multi-select-container .sb-modal{display:block;position:absolute;bottom:0;width:100%;--border-top:0.5px solid var(--white);z-index:11;background:var(--white)}.multi-select-container .sb-modal ul{list-style-type:none}.multi-select-container .sb-modal li{cursor:pointer;padding-bottom:8px;padding-top:8px;padding-left:16px}.value-label{width:270px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.multi-select-container .sb-forms-radio{margin-top:6px}.multi-select-container .sb-form-button{display:inline;padding:10px}.multi-select-container .sb-btn-primary-outline{color:var(--primary-color);background-color:transparent;border:.5px solid var(--primary-color);border-radius:4px;padding:10px 40px;font-size:16px;text-transform:uppercase;width:100%}.multi-select-container .sb-btn-primary{color:var(--white);background-color:var(--primary-color);border:.5px solid var(--primary-color);border-radius:4px;padding:10px 40px;font-size:16px;text-transform:uppercase;width:100%}.multi-select-container .header{padding:16px;margin-left:8px;font-weight:700}.multi-select-container .body{padding-top:8px;border-bottom:.5px solid var(--gray-100);border-top:.5px solid var(--gray-100);max-height:300px;overflow:scroll}.list-with-ellipsis:nth-child(3){float:left;font-size:12px;font-weight:700;margin-left:4px;width:50px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.list-with-ellipsis:nth-child(n+4){visibility:hidden}.multi-select-container .container{display:block;position:relative;padding-left:35px;margin-bottom:12px;cursor:pointer;font-size:22px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.container input{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.checkmark{position:absolute;top:3px;left:0;height:15px;width:15px;border:.4px solid var(--black)}.container:hover input~.checkmark{background-color:var(--white)}.container input:checked~.checkmark{background-color:var(--primary-600)}.checkmark:after{content:\"\";position:absolute;display:none}.container input:checked~.checkmark:after{display:block}.container .checkmark:after{left:5px;top:0;width:5px;height:10px;border:solid var(--white);border-width:0 2px 2px 0;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.sb-modal-dropdown-web ul{list-style-type:none;display:block;position:absolute;top:38px;left:0;background-color:#fff;width:100%;z-index:999;box-shadow:2px 2px 2px 2px #f0f8ff;border:2px solid #80a7ce;max-height:314px;overflow:scroll}.sb-modal-dropdown-web ul li{margin-top:10px;margin-bottom:8px;padding:8px;font-size:13px}.sb-modal-dropdown-web .selected-option{font-weight:700;background-color:#eee}::-webkit-scrollbar{width:6px}::-webkit-scrollbar-track{background:#f1f1f1}::-webkit-scrollbar-thumb{background:#888}::-webkit-scrollbar-thumb:hover{background:#555}.cursor-pointer{cursor:pointer}"]
            }] }
];
/** @nocollapse */
DynamicMultipleDropdownComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
DynamicMultipleDropdownComponent.propDecorators = {
    disabled: [{ type: Input }],
    field: [{ type: Input }],
    options: [{ type: Input }],
    label: [{ type: Input }],
    labelHtml: [{ type: Input }],
    placeholder: [{ type: Input }],
    isMultiple: [{ type: Input }],
    context: [{ type: Input }],
    formControlRef: [{ type: Input }],
    formGroup: [{ type: Input }],
    platform: [{ type: Input }],
    default: [{ type: Input }],
    contextData: [{ type: Input }],
    dataLoadStatusDelegate: [{ type: Input }],
    depends: [{ type: Input }],
    dependencyTerms: [{ type: Input }],
    docClick: [{ type: HostListener, args: ['document:click',] }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/dynamic-checkbox/dynamic-checkbox.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicCheckboxComponent {
    constructor() {
        this.ValueComparator = ValueComparator;
        this.onChangeFilter = new EventEmitter();
        this.dependencyTerms = [];
        this._ = _;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const desiredValue = (this.field.dataType === 'text') ? (this.field.default === 'Yes' ? true : false) : !!this.field.default;
        this.checked = desiredValue;
    }
    /**
     * @param {?} checked
     * @return {?}
     */
    onChecklistChange(checked) {
        this.checked = checked;
        /** @type {?} */
        const desiredValue = (this.field.dataType === 'text') ? (checked === true ? 'Yes' : 'No') : checked;
        this.formControlRef.setValue(desiredValue);
    }
}
DynamicCheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-dynamic-checkbox',
                template: "<div class=\"sb-checkbox sb-checkbox-primary\">\n  <input [attr.disabled]=\"disabled ? true : null\" type=\"checkbox\" [formControl]=\"formControlRef\" id=\"{{_.kebabCase(field.name) || field.code}}\"\n  name=\"{{_.kebabCase(field.name) || field.code}}\" [checked]=\"checked\" (change)=\"onChecklistChange($event.target.checked)\">\n  <label *ngIf=\"label\" for=\"{{_.kebabCase(field.name) || field.code}}\">{{label}}</label>\n</div>\n",
                styles: ["label{font-size:16px}.sb-checkbox{padding:0 0 0 8px}.container{position:relative;cursor:pointer;font-size:22px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.container input{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.container .checkmark{position:absolute;top:0;left:0;height:22px;width:22px;border:2px solid #000;border-radius:4px}.container input:checked~.checkmark{background-color:#2196f3}.checkmark:after{content:\"\";position:absolute;display:none}.container input:checked~.checkmark:after{display:block}.container .checkmark:after{left:7px;top:4px;width:5px;height:9px;border:solid #fff;border-width:0 3px 3px 0;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.checkbox-label{padding:2px 0 0 32px}.checkbox-row{display:-ms-grid;display:grid;-ms-grid-columns:10% 90%;grid-template-columns:10% 90%;grid-gap:0}.label-html{font-size:14px}"]
            }] }
];
/** @nocollapse */
DynamicCheckboxComponent.ctorParameters = () => [];
DynamicCheckboxComponent.propDecorators = {
    field: [{ type: Input }],
    disabled: [{ type: Input }],
    options: [{ type: Input }],
    label: [{ type: Input }],
    placeholder: [{ type: Input }],
    isMultiple: [{ type: Input }],
    context: [{ type: Input }],
    contextTerms: [{ type: Input }],
    formControlRef: [{ type: Input }],
    formGroup: [{ type: Input }],
    default: [{ type: Input }],
    contextData: [{ type: Input }],
    dataLoadStatusDelegate: [{ type: Input }],
    type: [{ type: Input }],
    styleClass: [{ type: Input }],
    onChangeFilter: [{ type: Output }],
    validations: [{ type: Input }],
    depends: [{ type: Input }],
    dependencyTerms: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/topicpicker/topicpicker.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TopicpickerComponent {
    constructor() {
        this.topicChange = new EventEmitter();
        this.dependencyTerms = [];
        this.dispose$ = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.formControlRef.valueChanges.pipe(tap((/**
         * @param {?} val
         * @return {?}
         */
        val => {
            console.log(val);
        })), takeUntil(this.dispose$)).subscribe();
        /** @type {?} */
        const selectedTopics = reduce(this.default, (/**
         * @param {?} collector
         * @param {?} element
         * @return {?}
         */
        (collector, element) => {
            if (typeof element === 'string') {
                collector.unformatted.push(element);
            }
            else if (get(element, 'identifier')) {
                collector.formatted.push(element);
            }
            return collector;
        }), { formatted: [], unformatted: [] });
        this.formatSelectedTopics(this.field.terms, selectedTopics.unformatted, selectedTopics.formatted);
        this.default = selectedTopics.unformatted;
        this.selectedNodes = Object.assign({}, selectedTopics.formatted);
        this.topicChange.emit(this.selectedTopics);
        if (!isEmpty(this.default)) {
            this.placeHolder = this.default && this.default.length + ' topics selected';
            this.formControlRef.setValue(this.default);
        }
        if (!isEmpty(this.depends)) {
            merge(...map$1(this.depends, (/**
             * @param {?} depend
             * @return {?}
             */
            depend => depend.valueChanges))).pipe(tap((/**
             * @param {?} value
             * @return {?}
             */
            (value) => {
                this.latestParentValue = value;
                this.isDependsInvalid = includes(map$1(this.depends, (/**
                 * @param {?} depend
                 * @return {?}
                 */
                depend => depend.invalid)), true);
                this.formControlRef.patchValue(null);
                this.placeHolder = '';
                this.default = [];
                this.selectedNodes = {};
                this.initTopicPicker(this.formatTopics(this.fetchAssociations()));
            })), takeUntil(this.dispose$)).subscribe();
            this.isDependsInvalid = includes(map$1(this.depends, (/**
             * @param {?} depend
             * @return {?}
             */
            depend => depend.invalid)), true);
        }
    }
    // tslint:disable-next-line:use-life-cycle-interface
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.initTopicPicker(this.formatTopics(this.field.terms));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.dispose$.next(null);
        this.dispose$.complete();
    }
    /**
     * @private
     * @param {?} topics
     * @param {?=} subTopic
     * @return {?}
     */
    formatTopics(topics, subTopic = false) {
        return map$1(topics, (/**
         * @param {?} topic
         * @return {?}
         */
        (topic) => ({
            id: topic.identifier,
            name: topic.name,
            selectable: subTopic ? 'selectable' : 'notselectable',
            nodes: this.formatTopics(topic.children, true)
        })));
    }
    /**
     * @private
     * @param {?} topics
     * @param {?} unformatted
     * @param {?} formatted
     * @return {?}
     */
    formatSelectedTopics(topics, unformatted, formatted) {
        forEach(topics, (/**
         * @param {?} topic
         * @return {?}
         */
        (topic) => {
            if (unformatted.includes(this.field.output ? topic[this.field.output] : topic.name) && !topic.children) {
                formatted.push({
                    identifier: topic.identifier,
                    name: topic.name
                });
            }
            if (topic.children) {
                this.formatSelectedTopics(topic.children, unformatted, formatted);
            }
        }));
    }
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    initTopicPicker(data) {
        $(`.topic-picker-selector_${this.field.code}`).treePicker({
            data: data,
            name: 'Topics',
            noDataMessage: 'noDataMessage',
            submitButtonText: 'Done',
            cancelButtonText: 'Cancel',
            removeAllText: 'Remove All',
            chooseAllText: 'Choose All',
            searchText: 'Search',
            selectedText: 'selected',
            picked: (!isEmpty(this.selectedNodes)) ? map$1(this.selectedNodes, 'identifier') : (!isEmpty(this.default) ? this.default : []),
            onSubmit: (/**
             * @param {?} selectedNodes
             * @return {?}
             */
            (selectedNodes) => {
                this.selectedNodes = selectedNodes;
                this.selectedTopics = map$1(selectedNodes, (/**
                 * @param {?} node
                 * @return {?}
                 */
                node => ({
                    identifier: node.id,
                    name: node.name
                })));
                this.placeHolder = this.selectedTopics.length + ' topics selected';
                this.topicChange.emit(this.selectedTopics);
                /** @type {?} */
                const topics = [];
                forEach(this.selectedTopics, (/**
                 * @param {?} value
                 * @param {?} index
                 * @return {?}
                 */
                (value, index) => {
                    if (this.field.output) {
                        topics.push(value[this.field.output]);
                    }
                    else {
                        topics.push(value.name);
                    }
                }));
                this.formControlRef.setValue(topics);
            }),
            nodeName: `topicSelector_${this.field.code}`,
            displayFormat: (/**
             * @param {?} picked
             * @return {?}
             */
            function (picked) { return this.placeHolder; }),
            minSearchQueryLength: 1,
            disabled: (/**
             * @param {?} node
             * @return {?}
             */
            (node) => {
                return this.disabled ? true : (this.depends ? (this.isDependsInvalid ? true : false) : false);
            })
        });
        setTimeout((/**
         * @return {?}
         */
        () => document.getElementById(`topicSelector_${this.field.code}`).classList.add(this.topicPickerClass)), 0);
    }
    /**
     * @return {?}
     */
    fetchAssociations() {
        // && this.context.value && this.field.association
        if (!isEmpty(this.depends)) {
            /** @type {?} */
            const filteredTerm = find(this.dependencyTerms, (/**
             * @param {?} terms
             * @return {?}
             */
            terms => {
                return !isEmpty(this.field.output) ? includes(this.getParentValue(), terms[this.field.output]) :
                    includes(this.getParentValue(), terms.name);
            }));
            if (filteredTerm) {
                this.tempAssociation = filter(filteredTerm.associations, (/**
                 * @param {?} association
                 * @return {?}
                 */
                association => {
                    return (this.field.sourceCategory) ? (association.category === this.field.sourceCategory) :
                        association.category === this.field.code;
                }));
                return this.tempAssociation;
            }
            else {
                return this.field.terms;
            }
        }
        else {
            return this.field.terms;
        }
    }
    /**
     * @return {?}
     */
    getParentValue() {
        return this.latestParentValue || compact(map$1(this.depends, 'value'));
    }
}
TopicpickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-topicpicker',
                template: "<div class=\"treepicker-parent\">\n  <label *ngIf=\"label\">{{label}}</label>\n  <div [attr.disabled]=\"disabled ? true : ( depends ? (isDependsInvalid ? true : null) : null )\" id=\"treePicker\" class=\"topic-picker-selector_{{field.code}} cursor-pointer list-border\">\n  {{placeHolder}}\n  </div>\n\n  <input [attr.disabled]=\"disabled ? true : ( depends ? (isDependsInvalid ? true : null) : null )\" [formControl]=\"formControlRef\" [placeholder]=\"placeHolder\" readonly hidden/>\n  <ng-container *ngFor=\"let validation of validations\">\n    <div class=\"cf-error\"\n      *ngIf=\"(validation.type && (validation.type).toLowerCase() && validation.message && formControlRef.errors && formControlRef.errors[(validation.type).toLowerCase()] && (formControlRef.dirty || formControlRef.touched))\">\n      {{ validation.message }}\n    </div>\n  </ng-container>\n</div>\n",
                styles: [".treepicker-parent{margin:1rem 0}label{display:block;font-size:1rem;margin:0}.topic-picker-selector{width:100%;padding:8px 16px;border:.5px solid #333;box-sizing:border-box}.cf-error{color:red;font-family:\"Noto Sans\";font-size:12px}.treepicker-parent .list-border{border:.5px solid var(--gray-400);padding:1.3rem;cursor:pointer;display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;left:0;height:40px}"]
            }] }
];
/** @nocollapse */
TopicpickerComponent.ctorParameters = () => [];
TopicpickerComponent.propDecorators = {
    selectedTopics: [{ type: Input }],
    topicPickerClass: [{ type: Input }],
    label: [{ type: Input }],
    disabled: [{ type: Input }],
    placeholder: [{ type: Input }],
    formControlRef: [{ type: Input }],
    field: [{ type: Input }],
    topicChange: [{ type: Output }],
    validations: [{ type: Input }],
    formGroup: [{ type: Input }],
    default: [{ type: Input }],
    depends: [{ type: Input }],
    dependencyTerms: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/keywords/keywords.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KeywordsComponent {
    constructor() {
        this.inputText = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!isEmpty(this.default)) {
            this.items = this.default;
        }
    }
}
KeywordsComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-keywords',
                template: "<div class=\"sb-keywords\">\n    <label *ngIf=\"label\">{{label}}</label>\n    <tag-input class=\"sb-keywordbox\" [formControl]=\"formControlRef\" [modelAsStrings]=\"true\" [(ngModel)]='items' [placeholder]=\"field.placeholder || 'Enter Keyword'\"\n    [disable]=\"disabled\"></tag-input>\n    <ng-container *ngFor=\"let validation of validations\">\n        <div class=\"cf-error\"\n          *ngIf=\"(validation.type && (validation.type).toLowerCase() && validation.message && formControlRef.errors && formControlRef.errors[(validation.type).toLowerCase()] && (formControlRef.dirty || formControlRef.touched))\">\n          {{ validation.message }}\n        </div>\n      </ng-container>\n</div>\n",
                styles: [".sb-keywords{margin:1rem 0}label{display:block;font-size:1rem;margin:0}.sb-keywordbox{width:100%;padding:8px 16px;border-bottom:.5px solid #333;box-sizing:border-box}.cf-error{color:red;font-family:\"Noto Sans\";font-size:12px}"]
            }] }
];
/** @nocollapse */
KeywordsComponent.ctorParameters = () => [];
KeywordsComponent.propDecorators = {
    label: [{ type: Input }],
    placeholder: [{ type: Input }],
    formControlRef: [{ type: Input }],
    field: [{ type: Input }],
    validations: [{ type: Input }],
    disabled: [{ type: Input }],
    default: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/dynamic-multi-select/dynamic-multi-select.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicMultiSelectComponent {
    constructor() {
        this.ValueComparator = ValueComparator;
        this.onChangeFilter = new EventEmitter();
        this.dependencyTerms = [];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.options) {
            this.options = [];
        }
        if (this.isOptionsClosure(this.options)) {
            this.options$ = (/** @type {?} */ (((/** @type {?} */ (this.options)))(this.formControlRef, this.depends, this.formGroup, (/**
             * @return {?}
             */
            () => this.dataLoadStatusDelegate.next('LOADING')), (/**
             * @return {?}
             */
            () => this.dataLoadStatusDelegate.next('LOADED')))));
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // if (this.context) {
        // this.contextValueChangesSubscription = this.context.valueChanges.pipe(
        //   tap(() => {
        //     this.formControlRef.patchValue(null);
        //   })
        // ).subscribe();
        // }
        this.dataLoadStatusDelegate.subscribe(console.log);
        if (this.field && this.field.range) {
            this.options = this.field.range;
        }
        if (!isEmpty(this.depends) && !this.isOptionsClosure(this.options)) {
            this.contextValueChangesSubscription = merge(...map$1(this.depends, (/**
             * @param {?} depend
             * @return {?}
             */
            depend => depend.valueChanges))).pipe(tap((/**
             * @param {?} value
             * @return {?}
             */
            (value) => {
                this.latestParentValue = value;
            }))).subscribe();
        }
        if (!isEmpty(this.field.depends)) {
            merge(...map$1(this.depends, (/**
             * @param {?} depend
             * @return {?}
             */
            depend => depend.valueChanges))).pipe(tap((/**
             * @return {?}
             */
            () => {
                // _.forEach(this.field.depends, depend => {
                //   if (!_.isEmpty(this.formGroup.get(depend))) {
                //     this.formGroup.get(depend).patchValue(null);
                //   }
                // });
                this.formControlRef.patchValue(null);
            }))).subscribe();
        }
        if (this.isOptionsClosure(this.options)) {
            // tslint:disable-next-line:max-line-length
            this.options$ = (/** @type {?} */ (((/** @type {?} */ (this.options)))(this.formControlRef, this.depends, this.formGroup, (/**
             * @return {?}
             */
            () => this.dataLoadStatusDelegate.next('LOADING')), (/**
             * @return {?}
             */
            () => this.dataLoadStatusDelegate.next('LOADED')))));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.contextValueChangesSubscription) {
            this.contextValueChangesSubscription.unsubscribe();
        }
    }
    /**
     * @param {?} options
     * @return {?}
     */
    isOptionsArray(options) {
        return Array.isArray(options);
    }
    /**
     * @param {?} options
     * @return {?}
     */
    isOptionsClosure(options) {
        return typeof options === 'function';
    }
    /**
     * @param {?} input
     * @return {?}
     */
    isOptionsMap(input) {
        return !Array.isArray(input) && typeof input === 'object';
    }
    /**
     * @param {?} input
     * @return {?}
     */
    isOptionsArrayMap(input) {
        return Array.isArray(input) && typeof input[0] === 'object';
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onChangeFacet($event) {
        /** @type {?} */
        const selectedObject = this.options.data[$event.currentTarget.options.selectedIndex - 1];
        /** @type {?} */
        const emitPayload = JSON.parse(JSON.stringify(this.options));
        emitPayload['data'] = selectedObject;
        emitPayload['selectedLabel'] = selectedObject.label;
        emitPayload['selectedValue'] = selectedObject.value;
        this.onChangeFilter.emit(emitPayload);
    }
    /**
     * @return {?}
     */
    fetchAssociations() {
        // && this.context.value && this.field.association
        if (!isEmpty(this.depends)) {
            /** @type {?} */
            const filteredTerm = find(this.dependencyTerms, (/**
             * @param {?} terms
             * @return {?}
             */
            terms => {
                return includes(this.getParentValue(), terms.identifier);
            }));
            if (filteredTerm) {
                this.tempAssociation = filter(filteredTerm.associations, (/**
                 * @param {?} association
                 * @return {?}
                 */
                association => {
                    return association.category === this.field.code;
                }));
                return this.tempAssociation;
            }
            else {
                return this.options;
            }
        }
        else {
            return this.options;
        }
    }
    /**
     * @return {?}
     */
    getParentValue() {
        return this.latestParentValue || compact(map$1(this.depends, 'value'));
    }
}
DynamicMultiSelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'sb-dynamic-multi-select',
                template: "<div class=\"sb-dropdown\" *ngIf=\"!type\">\n  <label>{{label}} {{context && 'has context'}}  {{context ?  field.context : '' }}</label>\n  <ng-container *ngIf=\"options\">\n    <div class=\"dropdown-container\">\n      <sb-icon-dropdown class=\"dropdown-icon\"></sb-icon-dropdown>\n      <!-- [attr.disabled]=\"disabled ? true : ( context ? (context.invalid ? true : null) : null )\" -->\n      <select [formControl]=\"formControlRef\"\n              [compareWith]=\"ValueComparator.valueComparator\" class=\"sb-dropdown-select\" id=\"sb-dropdown\"\n              name=\"sb-dropdown\" multiple>\n        <option [defaultSelected]=\"!default\" [ngValue]=\"null\" disabled>{{placeHolder}}\n        </option>\n        <ng-container *ngIf=\"field.range && isOptionsArrayMap(field.range) && !field.association\">\n          <option class=\"optionsArrayMap\" *ngFor=\"let option of field.range\" [ngValue]=\"option.value\">{{option.label}}</option>\n        </ng-container>\n        <ng-container *ngIf=\"field.range && isOptionsArray(field.range) && !isOptionsArrayMap(field.range) && !field.association\">\n          <option class=\"optionsArray\" *ngFor=\"let option of field.range\" [ngValue]=\"option || option\">{{option.name || option}}</option>\n        </ng-container>\n\n        <ng-container *ngIf=\"field.range && isOptionsClosure(field.range)\">\n          <option class=\"closure\" *ngFor=\"let option of options$ | async\" [ngValue]=\"option.value\">{{option.label}}</option>\n        </ng-container>\n\n        <!-- <ng-container *ngIf=\"isOptionsMap(options) && context && context.value && !field.association\">\n          <option *ngFor=\"let option of options[context.value]\" [ngValue]=\"option.value\">{{option.label}}</option>\n        </ng-container> -->\n\n        <ng-container *ngIf=\"!field.range && field.terms\">\n          <option class=\"optionsLast\" *ngFor=\"let option of fetchAssociations()\" [ngValue]=\"option.identifier\">{{option.name}}</option>\n        </ng-container>\n      </select>\n    </div>\n  </ng-container>\n</div>\n\n<!-- Dropdown for filters component -->\n<div class=\"sb-dropdown\" *ngIf=\"type === 'facet'\">\n  <label>{{label}}</label>\n  <ng-container *ngIf=\"options && options.data\">\n    <div class=\"dropdown-container\">\n      <sb-icon-dropdown class=\"dropdown-icon\"></sb-icon-dropdown>\n      <select [attr.disabled]=\"disabled ? true : ( context ? (context.invalid ? true : null) : null )\"\n        class=\"sb-dropdown-select\" [ngClass]=\"(styleClass ? styleClass : 'default-dropdown')\" id=\"sb-dropdown\" name=\"sb-dropdown\"\n        (change)=\"onChangeFacet($event)\" placeholder=\"placeHolder\">\n        <option *ngIf=\"!default\" [disabled]=\"true\" selected>{{placeHolder}}</option>\n        <option *ngFor=\"let option of options.data\" [ngValue]=\"option\" [selected]=\"options.default === option.value\">{{option.label}}</option>\n      </select>\n    </div>\n  </ng-container>\n</div>\n<ng-container *ngFor=\"let validation of validations\">\n  <div class=\"cf-error\"\n    *ngIf=\"(validation.type && (validation.type).toLowerCase() && validation.message && formControlRef.errors && formControlRef.errors[(validation.type).toLowerCase()] && (formControlRef.dirty || formControlRef.touched))\">\n    {{ validation.message }}\n  </div>\n</ng-container>\n\n<!-- Dropdown for filters component -->\n",
                styles: ["label{display:block;padding:10px;font-size:1rem}.dropdown-icon{position:absolute;top:.5rem;right:18px;z-index:1}.dropdown-container{position:relative}select[disabled]{opacity:.3}select{-webkit-appearance:none;-moz-appearance:none;text-indent:1px;text-overflow:''}.sb-dropdown-select{opacity:.99;color:#333;font-family:\"Noto Sans\";font-size:12px;font-weight:700;letter-spacing:0;line-height:17px}.sb-dropdown{margin-bottom:8px}.placeholder select option:first-child{color:#999}.option-default{color:#333;font-weight:700;font-size:12px}.sb-dropdown select{background-color:#fff;padding:10px 20px;font-size:14px;width:100%;border:.5px solid #333}.cf-error{color:red;font-family:\"Noto Sans\";font-size:12px}"]
            }] }
];
/** @nocollapse */
DynamicMultiSelectComponent.ctorParameters = () => [];
DynamicMultiSelectComponent.propDecorators = {
    field: [{ type: Input }],
    disabled: [{ type: Input }],
    options: [{ type: Input }],
    label: [{ type: Input }],
    placeHolder: [{ type: Input }],
    isMultiple: [{ type: Input }],
    context: [{ type: Input }],
    contextTerms: [{ type: Input }],
    formControlRef: [{ type: Input }],
    formGroup: [{ type: Input }],
    default: [{ type: Input }],
    contextData: [{ type: Input }],
    dataLoadStatusDelegate: [{ type: Input }],
    type: [{ type: Input }],
    styleClass: [{ type: Input }],
    onChangeFilter: [{ type: Output }],
    validations: [{ type: Input }],
    depends: [{ type: Input }],
    dependencyTerms: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/dynamic-field/dynamic-field.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const componentMapper = {
    textarea: DynamicTextareaComponent,
    text: DynamicTextboxComponent,
    select: DynamicDropdownComponent,
    multiselect: DynamicMultiSelectComponent,
    nestedselect: DynamicMultipleDropdownComponent,
    keywords: KeywordsComponent,
    dialcode: DynamicTextboxComponent,
    topicselector: TopicpickerComponent,
    licenses: DynamicDropdownComponent,
    label: DynamicTextboxComponent,
    number: DynamicTextboxComponent,
    checkbox: DynamicCheckboxComponent
};
class DynamicFieldDirective {
    /**
     * @param {?} resolver
     * @param {?} container
     * @param {?} renderer2
     * @param {?} elementRef
     */
    constructor(resolver, container, renderer2, elementRef) {
        this.resolver = resolver;
        this.container = container;
        this.renderer2 = renderer2;
        this.elementRef = elementRef;
        this.options = [];
        this.contextTerms = [];
        this.dependencyTerms = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const factory = this.resolver.resolveComponentFactory(componentMapper[this.field.inputType]);
        this.componentRef = this.container.createComponent(factory);
        // this.renderer2.appendChild(this.elementRef.nativeElement, this.componentRef.location.nativeElement);
        if (this.field.renderingHints && this.field.renderingHints.class) {
            this.setClassListOnElement(this.field.renderingHints.class);
        }
        this.componentRef.instance.field = this.field;
        this.componentRef.instance.formGroup = this.formGroup;
        this.componentRef.instance.formControlRef = this.formControlRef;
        this.componentRef.instance.label = this.label;
        this.componentRef.instance.placeholder = this.placeholder;
        this.componentRef.instance.options = this.options;
        this.componentRef.instance.context = this.context;
        this.componentRef.instance.contextTerms = this.contextTerms;
        this.componentRef.instance.depends = this.depends;
        this.componentRef.instance.dependencyTerms = this.dependencyTerms;
        this.componentRef.instance.default = this.default;
        this.componentRef.instance.dataLoadStatusDelegate = this.dataLoadStatusDelegate;
        this.componentRef.instance.validations = this.validations;
        this.componentRef.instance.disabled = this.disabled;
        // this.componentRef.instance = {
        //   field : this.field,
        //   formGroup : this.formGroup,
        //   formControlRef : this.formControlRef,
        //   label : this.label,
        //   options : this.options,
        //   context : this.context
        // };
    }
    /**
     * @param {?} cssClasses
     * @return {?}
     */
    setClassListOnElement(cssClasses) {
        /** @type {?} */
        const classList = cssClasses.split(' ');
        forEach(classList, (/**
         * @param {?} cssClass
         * @return {?}
         */
        cssClass => {
            this.renderer2.addClass(this.componentRef.location.nativeElement, cssClass);
        }));
    }
}
DynamicFieldDirective.decorators = [
    { type: Directive, args: [{
                selector: '[sbDynamicField]'
            },] }
];
/** @nocollapse */
DynamicFieldDirective.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef },
    { type: Renderer2 },
    { type: ElementRef }
];
DynamicFieldDirective.propDecorators = {
    field: [{ type: Input }],
    formGroup: [{ type: Input }],
    formControlRef: [{ type: Input }],
    disabled: [{ type: Input }],
    label: [{ type: Input }],
    options: [{ type: Input }],
    placeholder: [{ type: Input }],
    context: [{ type: Input }],
    validations: [{ type: Input }],
    contextTerms: [{ type: Input }],
    depends: [{ type: Input }],
    dependencyTerms: [{ type: Input }],
    default: [{ type: Input }],
    dataLoadStatusDelegate: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/common-form-elements.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CommonFormElementsModule {
}
CommonFormElementsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    CommonFormElementsComponent,
                    DropdownComponent,
                    TextboxComponent,
                    TextareaComponent,
                    CheckboxComponent,
                    FormComponent,
                    OptionGroupComponent,
                    DropdownIconComponent,
                    MultipleDropdownComponent,
                    CaretDownComponent,
                    RedExclamationComponent,
                    GreenTickComponent,
                    EmptyCircleComponent,
                    FiltersComponent,
                    PillsComponent,
                    DynamicFormComponent,
                    DynamicTextboxComponent,
                    DynamicTextareaComponent,
                    DynamicDropdownComponent,
                    DynamicMultipleDropdownComponent,
                    DynamicCheckboxComponent,
                    DynamicFieldDirective,
                    TopicpickerComponent,
                    KeywordsComponent,
                    DynamicMultiSelectComponent
                ],
                imports: [
                    CommonModule,
                    ReactiveFormsModule,
                    FormsModule,
                    PipesModule,
                    TagInputModule
                ],
                exports: [
                    CommonFormElementsComponent,
                    DropdownComponent,
                    CaretDownComponent,
                    TextboxComponent,
                    TextareaComponent,
                    CheckboxComponent,
                    FormComponent,
                    OptionGroupComponent,
                    DropdownIconComponent,
                    RedExclamationComponent,
                    GreenTickComponent,
                    EmptyCircleComponent,
                    MultipleDropdownComponent,
                    FiltersComponent,
                    DynamicFormComponent,
                    DynamicTextboxComponent,
                    DynamicTextareaComponent,
                    DynamicDropdownComponent,
                    DynamicMultipleDropdownComponent,
                    DynamicCheckboxComponent,
                    DynamicMultiSelectComponent,
                    TopicpickerComponent,
                    KeywordsComponent,
                    DynamicFieldDirective
                ],
                entryComponents: [
                    DynamicFormComponent,
                    CommonFormElementsComponent,
                    DynamicTextboxComponent,
                    DynamicTextareaComponent,
                    DynamicDropdownComponent,
                    DynamicMultipleDropdownComponent,
                    DynamicCheckboxComponent,
                    DynamicMultiSelectComponent,
                    TopicpickerComponent,
                    KeywordsComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: common-form-elements.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { CommonFormElementsComponent, CommonFormElementsModule, FieldConfigInputType, FieldConfigValidationType, FilterType, CheckboxComponent as ɵd, DropdownComponent as ɵa, DynamicCheckboxComponent as ɵt, DynamicDropdownComponent as ɵr, DynamicFieldDirective as ɵu, DynamicFormComponent as ɵo, DynamicMultiSelectComponent as ɵx, DynamicMultipleDropdownComponent as ɵs, DynamicTextareaComponent as ɵq, DynamicTextboxComponent as ɵp, FiltersComponent as ɵm, FormComponent as ɵe, CaretDownComponent as ɵi, DropdownIconComponent as ɵg, EmptyCircleComponent as ɵl, GreenTickComponent as ɵk, RedExclamationComponent as ɵj, KeywordsComponent as ɵw, MultipleDropdownComponent as ɵh, OptionGroupComponent as ɵf, PillsComponent as ɵn, PipesModule as ɵy, TransposeHtmlPipe as ɵz, TextareaComponent as ɵc, TextboxComponent as ɵb, TopicpickerComponent as ɵv };

//# sourceMappingURL=common-form-elements.js.map